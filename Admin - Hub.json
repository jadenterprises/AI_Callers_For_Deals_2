{"files":[{"id":"766480ed-226b-4f2d-bbcb-e21690c2f06d","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"America/Chicago\",\n  \"dependencies\": {\n    \"enabledAdvancedServices\": [{\n      \"userSymbol\": \"Sheets\",\n      \"serviceId\": \"sheets\",\n      \"version\": \"v4\"\n    }],\n    \"libraries\": [{\n      \"userSymbol\": \"OutboundLib\",\n      \"libraryId\": \"14fjQkeRpDdgvNh_9XPhegZKI-jJ0epbchiL8oj2sbGmGU_s5GOQheuO-\",\n      \"version\": \"0\"\n    }]\n  },\n  \"webapp\": {\n    \"access\": \"ANYONE_ANONYMOUS\",\n    \"executeAs\": \"USER_DEPLOYING\"\n  },\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"oauthScopes\": [\"https://www.googleapis.com/auth/spreadsheets\", \"https://www.googleapis.com/auth/script.external_request\", \"https://www.googleapis.com/auth/cloud-platform\", \"https://www.googleapis.com/auth/drive\", \"https://www.googleapis.com/auth/script.scriptapp\", \"https://www.googleapis.com/auth/drive.readonly\", \"https://www.googleapis.com/auth/userinfo.email\"],\n  \"runtimeVersion\": \"V8\"\n}"},{"id":"130c4fb0-af97-428f-95a0-f4f81e5e38f7","name":"Bootstrap","type":"server_js","source":"// Bootstrap.js - Handles initial setup and routing\n\nfunction __bootstrapApplyProps_(p) {\n  try {\n    var P \u003d PropertiesService.getScriptProperties();\n    P.setProperties(p || {}, true);\n    P.setProperty(\u0027BOOTSTRAPPED\u0027, \u00271\u0027);\n    return { ok: true, keys: Object.keys(p || {}).length };\n  } catch (e) { \n    return { ok: false, error: String(e) }; \n  }\n}\n\nfunction __bootstrapSetProps(p) { \n  return __bootstrapApplyProps_(p); \n}\n\nfunction __bootstrapGetProps(keys) {\n  try {\n    var P \u003d PropertiesService.getScriptProperties();\n    var all \u003d P.getProperties();\n    if (Object.prototype.toString.call(keys) \u003d\u003d\u003d \u0027[object Array]\u0027 \u0026\u0026 keys.length) {\n      var out \u003d {}; \n      keys.forEach(function(k) { \n        if (all.hasOwnProperty(k)) out[k] \u003d all[k]; \n      });\n      return out;\n    }\n    return all;\n  } catch (e) { \n    return { ok: false, error: String(e) }; \n  }\n}\n\nfunction doGet(e) {\n  try {\n    // Handle bootstrap operations\n    if (e \u0026\u0026 e.parameter \u0026\u0026 e.parameter.apply) {\n      var json \u003d Utilities.newBlob(Utilities.base64DecodeWebSafe(e.parameter.apply)).getDataAsString();\n      var props \u003d JSON.parse(json);\n      var r \u003d __bootstrapApplyProps_(props);\n      return ContentService.createTextOutput(JSON.stringify(r)).setMimeType(ContentService.MimeType.JSON);\n    }\n    \n    if (e \u0026\u0026 e.parameter \u0026\u0026 e.parameter.ping) {\n      var want \u003d [];\n      try {\n        if (e.parameter.want) {\n          var wjson \u003d Utilities.newBlob(Utilities.base64DecodeWebSafe(e.parameter.want)).getDataAsString();\n          want \u003d JSON.parse(wjson);\n        }\n      } catch (_) {}\n      var P \u003d PropertiesService.getScriptProperties();\n      var all \u003d P.getProperties();\n      var has \u003d {};\n      (want || []).forEach(function(k) { \n        has[k] \u003d !!all[k]; \n      });\n      return ContentService.createTextOutput(JSON.stringify({\n        ok: true, \n        authorized: true, \n        anyProps: Object.keys(all || {}).length \u003e 0, \n        hasProps: has\n      })).setMimeType(ContentService.MimeType.JSON);\n    }\n    \n    // Default GET response\n    return ContentService.createTextOutput(\"Hub API is active. Use POST for actions.\")\n      .setMimeType(ContentService.MimeType.TEXT);\n    \n  } catch (err) {\n    return ContentService.createTextOutput(JSON.stringify({ \n      ok: false, \n      error: String(err) \n    })).setMimeType(ContentService.MimeType.JSON);\n  }\n}\n\nfunction doPost(e) {\n  try {\n    // Check for bootstrap initialization first\n    var P \u003d PropertiesService.getScriptProperties();\n    var initialized \u003d !!(P.getProperty(\u0027CLIENT_TOKEN\u0027) || P.getProperty(\u0027BOOTSTRAPPED\u0027));\n    \n    if (!initialized) {\n      var body \u003d e \u0026\u0026 e.postData \u0026\u0026 e.postData.contents ? JSON.parse(e.postData.contents) : {};\n      if (body \u0026\u0026 body.__bootstrapProps) {\n        var r \u003d __bootstrapApplyProps_(body.__bootstrapProps);\n        return ContentService.createTextOutput(JSON.stringify(r))\n               .setMimeType(ContentService.MimeType.JSON);\n      }\n      // Not initialized and no bootstrap props - return error\n      return ContentService.createTextOutput(JSON.stringify({ \n        ok: false, \n        error: \u0027NOT_INITIALIZED\u0027 \n      })).setMimeType(ContentService.MimeType.JSON);\n    }\n    \n    // System is initialized - delegate to Hub API handler\n    return doPostHub(e);\n    \n  } catch (err) {\n    return ContentService.createTextOutput(JSON.stringify({ \n      ok: false, \n      error: String(err) \n    })).setMimeType(ContentService.MimeType.JSON);\n  }\n}"},{"id":"71b2084c-f1b8-411a-9982-607f44156143","name":"ConfigLoader","type":"server_js","source":"\n/**\n * Config Loader (top-level; works in stand-alone editors and bound sheets)\n * Usage:\n *   • Run manualConfigAuto()                     — auto-detects the matching retell-provision.json\n *   • Or run manualConfigFromProvisionRecord(\u0027\u003cDrive URL or File ID\u003e\u0027)\n * Behavior:\n *   • Merges Script Properties (does not wipe others)\n *   • Writes PROVISION_RECORD_ID and RECORD_ID for future zero‑arg runs\n *\n * Requires scopes (manifest):\n *   https://www.googleapis.com/auth/drive.readonly\n *   https://www.googleapis.com/auth/script.external_request\n *   (optional) https://www.googleapis.com/auth/userinfo.email\n */\n\n/** ───────────────────────── Helpers ───────────────────────── **/\n\n/** Extract a Drive File ID from a raw id or a full Drive URL. */\nfunction __cfg_parseRecordArg(arg) {\n  var a \u003d String(arg || \u0027\u0027).trim();\n  if (!a) return \u0027\u0027;\n  if (/^[A-Za-z0-9_-]{20,}$/.test(a)) return a;         // already looks like an id\n  var m \u003d a.match(/[-\\w]{25,}/g);                       // first long-ish token from URL\n  return (m \u0026\u0026 m[0]) ? m[0] : \u0027\u0027;\n}\n\n/**\n * Drive-wide scan (most recent first) to find a provision file that references *this* script id.\n * Tight bounds for speed; adequate for typical libraries.\n */\nfunction __cfg_autoFindRecordId() {\n  var token \u003d ScriptApp.getOAuthToken();\n  var q \u003d \"name\u003d\u0027retell-provision.json\u0027 and trashed\u003dfalse\";\n  var pageToken \u003d null, examined \u003d 0;\n\n  for (var page \u003d 0; page \u003c 5; page++) {\n    var url \u003d \"https://www.googleapis.com/drive/v3/files\"\n            + \"?q\u003d\" + encodeURIComponent(q)\n            + \"\u0026fields\u003dfiles(id,name,modifiedTime),nextPageToken\"\n            + \"\u0026orderBy\u003dmodifiedTime desc\"\n            + \"\u0026pageSize\u003d100\"\n            + (pageToken ? \"\u0026pageToken\u003d\"+encodeURIComponent(pageToken) : \"\")\n            + \"\u0026includeItemsFromAllDrives\u003dtrue\u0026supportsAllDrives\u003dtrue\";\n\n    var r \u003d UrlFetchApp.fetch(url, { headers:{ Authorization:\"Bearer \" + token }, muteHttpExceptions:true });\n    if (r.getResponseCode() \u003e\u003d 300) break;\n\n    var j \u003d JSON.parse(r.getContentText() || \"{}\");\n    var arr \u003d j.files || [];\n    for (var i\u003d0; i\u003carr.length \u0026\u0026 examined\u003c400; i++) {\n      examined++;\n      var fid \u003d arr[i].id;\n      try {\n        var res \u003d UrlFetchApp.fetch(\n          \"https://www.googleapis.com/drive/v3/files/\" + encodeURIComponent(fid) + \"?alt\u003dmedia\u0026supportsAllDrives\u003dtrue\",\n          { headers:{ Authorization:\"Bearer \" + token }, muteHttpExceptions:true }\n        );\n        if (res.getResponseCode() \u003e\u003d 300) continue;\n\n        var rec \u003d JSON.parse(res.getContentText() || \"{}\");\n        var myId \u003d ScriptApp.getScriptId();\n        var s \u003d (rec \u0026\u0026 rec.scripts) || {};\n        if (s.hubScriptId\u003d\u003d\u003dmyId || s.portalScriptId\u003d\u003d\u003dmyId || s.outboundScriptId\u003d\u003d\u003dmyId || s.resultsScriptId\u003d\u003d\u003dmyId) {\n          return fid;\n        }\n      } catch (_) {}\n    }\n    pageToken \u003d j.nextPageToken;\n    if (!pageToken) break;\n  }\n  return \"\";\n}\n\n/** Download the provision record JSON via Drive v3 media endpoint. */\nfunction __cfg_fetchRecord(fileId) {\n  var token \u003d ScriptApp.getOAuthToken();\n  var resp \u003d UrlFetchApp.fetch(\n    \"https://www.googleapis.com/drive/v3/files/\" + encodeURIComponent(fileId) + \"?alt\u003dmedia\u0026supportsAllDrives\u003dtrue\",\n    { headers:{ Authorization:\"Bearer \" + token }, muteHttpExceptions:true }\n  );\n  if (resp.getResponseCode() \u003e\u003d 300) {\n    throw new Error(\"Failed to download provision record: HTTP \" + resp.getResponseCode() + \" \" + resp.getContentText());\n  }\n  return JSON.parse(resp.getContentText() || \"{}\");\n}\n\n/** ─────────────────── Main: load \u0026 apply ─────────────────── **/\n\n/** Zero-argument convenience: select this in the editor and click Run ▶︎ */\nfunction manualConfigAuto() {\n  return manualConfigFromProvisionRecord(\u0027\u0027);\n}\n\n/**\n * Load from a specific File ID or full Drive URL; if omitted, auto-detect.\n * @param {string\u003d} recordFileIdOrUrl\n */\nfunction manualConfigFromProvisionRecord(recordFileIdOrUrl) {\n  // 1) Resolve the record id\n  var id \u003d __cfg_parseRecordArg(recordFileIdOrUrl);\n\n  // Prefer an id already stored on this script\n  if (!id) {\n    try {\n      var P0 \u003d PropertiesService.getScriptProperties();\n      id \u003d P0.getProperty(\u0027PROVISION_RECORD_ID\u0027) || P0.getProperty(\u0027RECORD_ID\u0027) || \u0027\u0027;\n    } catch (_) {}\n  }\n\n  // Auto-detect as next best\n  if (!id) id \u003d __cfg_autoFindRecordId();\n\n  // In a bound Sheet, give the user a prompt as a last resort\n  if (!id \u0026\u0026 typeof SpreadsheetApp!\u003d\u003d\u0027undefined\u0027 \u0026\u0026 SpreadsheetApp.getUi) {\n    try {\n      var ui \u003d SpreadsheetApp.getUi();\n      var res \u003d ui.prompt(\n        \u0027Paste the Provision Record link (or ID)\u0027,\n        \u0027Tip: you can paste the full Drive URL – no need to extract the ID.\u0027,\n        ui.ButtonSet.OK_CANCEL\n      );\n      if (res.getSelectedButton() \u003d\u003d\u003d ui.Button.OK) {\n        id \u003d __cfg_parseRecordArg(res.getResponseText());\n      }\n    } catch(_) {}\n  }\n\n  if (!id) {\n    var msg \u003d \"Could not locate a matching \u0027retell-provision.json\u0027. Ensure it exists and you have access.\";\n    Logger.log(msg);\n    if (typeof SpreadsheetApp!\u003d\u003d\u0027undefined\u0027 \u0026\u0026 SpreadsheetApp.getUi) { try{ SpreadsheetApp.getUi().alert(msg); }catch(_){} }\n    return { ok:false, error: msg };\n  }\n\n  // 2) Fetch record \u0026 determine role for this script\n  var rec \u003d __cfg_fetchRecord(id);\n  if (!rec.scripts || !rec.props) {\n    var e2 \u003d \"Provision record missing \u0027scripts\u0027 or \u0027props\u0027.\";\n    Logger.log(e2);\n    return { ok:false, error: e2 };\n  }\n\n  var myScriptId \u003d ScriptApp.getScriptId();\n  var role \u003d \"Unknown\", props \u003d null;\n\n  if (rec.scripts.hubScriptId \u003d\u003d\u003d myScriptId)           { role\u003d\"Hub\";     props\u003drec.props.hubProps; }\n  else if (rec.scripts.portalScriptId \u003d\u003d\u003d myScriptId)   { role\u003d\"Portal\";  props\u003drec.props.portalProps; }\n  else if (rec.scripts.outboundScriptId \u003d\u003d\u003d myScriptId) { role\u003d\"Outbound\"; props\u003drec.props.outboundProps; }\n  else if (rec.scripts.resultsScriptId \u003d\u003d\u003d myScriptId)  { role\u003d\"Results\";  props\u003drec.props.resultsProps; }\n\n  // Fallback for bound Sheets (match active spreadsheet id)\n  if (!props \u0026\u0026 typeof SpreadsheetApp!\u003d\u003d\u0027undefined\u0027 \u0026\u0026 SpreadsheetApp.getActiveSpreadsheet) {\n    try {\n      var ssId \u003d SpreadsheetApp.getActiveSpreadsheet().getId();\n      if (rec.sheets \u0026\u0026 rec.sheets.outboundId \u003d\u003d\u003d ssId) { role\u003d\"Outbound (ID Match)\"; props\u003drec.props.outboundProps; }\n      else if (rec.sheets \u0026\u0026 rec.sheets.resultsId \u003d\u003d\u003d ssId) { role\u003d\"Results (ID Match)\"; props\u003drec.props.resultsProps; }\n    } catch(_) {}\n  }\n\n  if (!props) {\n    var e3 \u003d \"This script ID (\" + myScriptId + \") did not match any script in the provision record.\";\n    Logger.log(e3);\n    if (typeof SpreadsheetApp!\u003d\u003d\u0027undefined\u0027 \u0026\u0026 SpreadsheetApp.getUi) { try{ SpreadsheetApp.getUi().alert(e3); }catch(_){} }\n    return { ok:false, error: e3 };\n  }\n\n  // 3) Apply properties (merge) and remember the record id\n  try {\n    var P \u003d PropertiesService.getScriptProperties();\n    P.setProperties(props, false);            // merge (append) keys safely\n    P.setProperty(\u0027BOOTSTRAPPED\u0027,\u00271\u0027);\n    P.setProperty(\u0027PROVISION_RECORD_ID\u0027, id); // remember for zero‑arg runs\n    P.setProperty(\u0027RECORD_ID\u0027, id);\n\n    var count \u003d Object.keys(props).length;\n    var msgOk \u003d \"Applied \" + count + \" properties for role \" + role + \" (record \" + id + \").\";\n    Logger.log(msgOk);\n    if (typeof SpreadsheetApp!\u003d\u003d\u0027undefined\u0027 \u0026\u0026 SpreadsheetApp.getUi) { try{ SpreadsheetApp.getUi().alert(msgOk); }catch(_){} }\n    return { ok:true, message: msgOk, count: count, role: role, recordId: id };\n  } catch (e) {\n    var e4 \u003d \"Failed to apply Script Properties: \" + e;\n    Logger.log(e4);\n    return { ok:false, error: e4 };\n  }\n}\n"},{"id":"c957851c-c2ad-4b30-a147-4745c6feb532","name":"Hub_API","type":"server_js","source":"// Hub_API.js - Main API handler (called from Bootstrap.js)\r\n\r\nfunction json_(o) { \r\n  return ContentService.createTextOutput(JSON.stringify(o))\r\n    .setMimeType(ContentService.MimeType.JSON); \r\n}\r\n\r\nfunction cooldownRemainingSeconds_(key, minutes) {\r\n  const ts \u003d Number(PropertiesService.getScriptProperties().getProperty(\u0027COOLDOWN_\u0027 + key) || 0);\r\n  if (!ts) return 0;\r\n  const until \u003d ts + minutes * 60 * 1000;\r\n  return Math.max(0, Math.ceil((until - Date.now()) / 1000));\r\n}\r\n\r\nfunction markCooldownNow_(key) {\r\n  PropertiesService.getScriptProperties().setProperty(\u0027COOLDOWN_\u0027 + key, String(Date.now()));\r\n}\r\n\r\n// Main POST handler for Hub API (called from Bootstrap.js doPost)\r\nfunction doPostHub(e) {\r\n  let params;\r\n  try {\r\n    params \u003d JSON.parse(e.postData.contents);\r\n  } catch (err) {\r\n    return json_({ ok: false, error: \u0027INVALID_REQUEST_BODY\u0027 });\r\n  }\r\n\r\n  const token \u003d String(params.token || \u0027\u0027);\r\n  \r\n  if (token !\u003d\u003d CFG().CLIENT_TOKEN) {\r\n    return json_({ ok: false, error: \u0027UNAUTHORIZED\u0027 });\r\n  }\r\n\r\n  const action \u003d String(params.action || \u0027\u0027).toLowerCase();\r\n  console.log(`Hub API: Received action \u0027${action}\u0027.`);\r\n  \r\n  if (action \u003d\u003d\u003d \u0027balance\u0027) {\r\n    return json_({ ok: true, balance: getBalance_() });\r\n  }\r\n\r\n  if (action \u003d\u003d\u003d \u0027send_run\u0027) {\r\n    const run \u003d parseInt(params.run || \u00271\u0027, 10);\r\n    const count \u003d parseInt(params.count || \u00270\u0027, 10);\r\n    if (run \u003c 1 || run \u003e 8) {\r\n      return json_({ ok: false, error: \u0027Invalid run number.\u0027 });\r\n    }\r\n    \r\n    // Check if function exists\r\n    if (typeof startHubSendRun !\u003d\u003d \u0027function\u0027) {\r\n      return json_({ ok: false, error: \u0027Send function not available\u0027 });\r\n    }\r\n    \r\n    markCooldownNow_(\u0027send\u0027);\r\n    const TAB_OUTBOUND \u003d \u0027Outbound Leads\u0027; // Define here if not imported\r\n    const result \u003d startHubSendRun(TAB_OUTBOUND, run, count);\r\n    return json_(result);\r\n  }\r\n\r\n  if (action \u003d\u003d\u003d \u0027cooldown_status\u0027) {\r\n    const COOLDOWN_MINUTES_CLIENT \u003d 21; // Default value\r\n    const C \u003d CFG();\r\n    const sendCooldown \u003d COOLDOWN_MINUTES_CLIENT;\r\n    const ingestCooldown \u003d C.INGEST_COOLDOWN_MIN || 20;\r\n    return json_({\r\n      ok: true,\r\n      send_seconds: cooldownRemainingSeconds_(\u0027send\u0027, sendCooldown),\r\n      ingest_seconds: cooldownRemainingSeconds_(\u0027ingest\u0027, ingestCooldown)\r\n    });\r\n  }\r\n\r\n  if (action \u003d\u003d\u003d \u0027ingest\u0027) {\r\n    // Check if function exists\r\n    if (typeof hubIngestWebhooks_ !\u003d\u003d \u0027function\u0027) {\r\n      return json_({ ok: false, error: \u0027Ingest function not available\u0027 });\r\n    }\r\n    \r\n    const ingestCooldown \u003d CFG().INGEST_COOLDOWN_MIN || 20;\r\n    const remaining \u003d cooldownRemainingSeconds_(\u0027ingest\u0027, ingestCooldown);\r\n    if (remaining \u003e 0) {\r\n      return json_({ ok: false, error: `Please wait ${Math.ceil(remaining/60)} min to ingest.` });\r\n    }\r\n    markCooldownNow_(\u0027ingest\u0027);\r\n    const result \u003d hubIngestWebhooks_();\r\n    return json_(result);\r\n  }\r\n\r\n  if (action \u003d\u003d\u003d \u0027portal_auth\u0027) {\r\n    const pass \u003d String(params.password || \u0027\u0027);\r\n    const valid \u003d (pass \u0026\u0026 CFG().PORTAL_PASSWORD \u0026\u0026 pass \u003d\u003d\u003d CFG().PORTAL_PASSWORD);\r\n    return json_({ ok: valid });\r\n  }\r\n\r\n  return json_({ ok: false, error: \u0027UNKNOWN_ACTION\u0027 });\r\n}\r\n\r\n/**\r\n * Deletes any existing webhook polling triggers and creates a new one\r\n * that runs every 5 minutes. Stores the trigger\u0027s start time and ID.\r\n */\r\nfunction startWebhookIngestPolling_() {\r\n  const handlerFunction \u003d \u0027hubIngestWebhooks_\u0027;\r\n\r\n  // 1. Delete any existing triggers for this handler to prevent duplicates.\r\n  const allTriggers \u003d ScriptApp.getProjectTriggers();\r\n  for (const trigger of allTriggers) {\r\n    if (trigger.getHandlerFunction() \u003d\u003d\u003d handlerFunction) {\r\n      ScriptApp.deleteTrigger(trigger);\r\n      console.log(`Deleted existing polling trigger: ${trigger.getUniqueId()}`);\r\n    }\r\n  }\r\n\r\n  // 2. Create a new trigger to run every 5 minutes.\r\n  const newTrigger \u003d ScriptApp.newTrigger(handlerFunction)\r\n    .timeBased()\r\n    .everyMinutes(5)\r\n    .create();\r\n  console.log(`Created new 5-minute polling trigger: ${newTrigger.getUniqueId()}`);\r\n\r\n  // 3. Store the creation time and ID to manage its 90-minute lifespan.\r\n  const P \u003d PropertiesService.getScriptProperties();\r\n  P.setProperties({\r\n    \u0027WEBHOOK_POLL_START_TIME\u0027: Date.now(),\r\n    \u0027WEBHOOK_POLL_TRIGGER_ID\u0027: newTrigger.getUniqueId()\r\n  });\r\n}"},{"id":"57726d36-fa0b-474e-a249-c259df7ec017","name":"Hub_ArchiveAndResults","type":"server_js","source":"// Hub_ArchiveAndResults.js (Fixed) - Part 1\n// This file handles archive management and results processing\n\nfunction _logPlacementDecision_(rowIndex, row, reason, targetTab) {\n  console.log(`Row ${rowIndex + 1}: ${reason} → ${targetTab || \u0027skipped\u0027}`);\n  console.log(JSON.stringify(row));\n}\n\nfunction _getPhoneSetFromSheet_(ss, tabName) {\n  const sheet \u003d ss.getSheetByName(tabName);\n  if (!sheet) return new Set();\n\n  const data \u003d sheet.getDataRange().getValues();\n  const headers \u003d data[0];\n  const phoneCol \u003d headers.indexOf(\"Phone\");\n  if (phoneCol \u003d\u003d\u003d -1) return new Set();\n\n  const set \u003d new Set();\n  for (let i \u003d 1; i \u003c data.length; i++) {\n    const phone \u003d String(data[i][phoneCol]).replace(/\\D/g, \u0027\u0027);\n    if (phone.length \u003e\u003d 10) set.add(phone.slice(-10)); // Normalize to last 10 digits\n  }\n  return set;\n}\n\nfunction _listsSpreadsheet_() {\n  const id \u003d PropertiesService.getScriptProperties().getProperty(\u0027RESULTS_SS_ID\u0027);\n  return SpreadsheetApp.openById(id);\n}\n\nfunction ensureMonthlyArchive() {\n  const folder \u003d DriveApp.getFolderById(CFG().FOLDER_ID);\n  const name \u003d archiveNameFor_(new Date());\n\n  // Try to find existing\n  const files \u003d folder.getFilesByName(name);\n  if (files.hasNext()) {\n    const id \u003d files.next().getId();\n    const ss \u003d ssById_(id);\n    const sh \u003d sh_(ss, \u0027Archive\u0027);\n    ensureHeaders_(sh, ARCHIVE_HEADERS);\n    PropertiesService.getScriptProperties().setProperty(\u0027LAST_ARCHIVE_FILE_ID\u0027, id);\n    return { id, sheet: sh };\n  }\n\n  // Create new\n  const ss \u003d SpreadsheetApp.create(name);\n  DriveApp.getFileById(ss.getId()).moveTo(folder);\n\n  // Fixed: Proper sheet deletion logic\n  const sheets \u003d ss.getSheets();\n  if (sheets.length \u003e 1) {\n    // Keep first sheet, delete others from the end\n    for (let i \u003d sheets.length - 1; i \u003e 0; i--) {\n      ss.deleteSheet(sheets[i]);\n    }\n  }\n  \n  // Rename the remaining sheet to Archive\n  const remainingSheet \u003d ss.getSheets()[0];\n  remainingSheet.setName(\u0027Archive\u0027);\n  ensureHeaders_(remainingSheet, ARCHIVE_HEADERS);\n\n  PropertiesService.getScriptProperties().setProperty(\u0027LAST_ARCHIVE_FILE_ID\u0027, ss.getId());\n  return { id: ss.getId(), sheet: remainingSheet };\n}\n\nfunction appendArchiveChunked_(sh, rows) {\n  const CHUNK \u003d 1000;\n  let start \u003d sh.getLastRow() + 1;\n  for (let i \u003d 0; i \u003c rows.length; i +\u003d CHUNK) {\n    const block \u003d rows.slice(i, i + CHUNK);\n    sh.getRange(start, 1, block.length, block[0].length).setValues(block);\n    start +\u003d block.length;\n  }\n}\n\n/** Read the current CSV object (text + generation) without mutating it. */\nfunction gcsPeekCsvText_() {\n  const token \u003d ScriptApp.getOAuthToken();\n  const bucket \u003d CFG().GCS_BUCKET;\n  const path \u003d CFG().GCS_RESULTS_PATH;\n  const base \u003d `https://storage.googleapis.com/storage/v1/b/${bucket}/o`;\n  const enc \u003d encodeURIComponent(path);\n\n  // 1) metadata (for generation)\n  const meta \u003d UrlFetchApp.fetch(`${base}/${enc}?fields\u003dgeneration,size`, {\n    headers: { Authorization: \u0027Bearer \u0027 + token },\n    muteHttpExceptions: true\n  });\n  if (meta.getResponseCode() !\u003d\u003d 200) return null;\n  const j \u003d JSON.parse(meta.getContentText() || \u0027{}\u0027);\n  const gen \u003d j.generation;\n\n  // 2) media\n  const media \u003d UrlFetchApp.fetch(`${base}/${enc}?alt\u003dmedia`, {\n    headers: { Authorization: \u0027Bearer \u0027 + token },\n    muteHttpExceptions: true\n  });\n  if (media.getResponseCode() !\u003d\u003d 200) return null;\n\n  return { text: media.getContentText(), generation: gen };\n}\n\n/** Overwrite the live CSV with new content (leftovers) using generation match. */\nfunction gcsOverwriteCsv_(csvText, ifGenerationMatch) {\n  const token \u003d ScriptApp.getOAuthToken();\n  const bucket \u003d CFG().GCS_BUCKET;\n  const path \u003d CFG().GCS_RESULTS_PATH;\n  const enc \u003d encodeURIComponent(path);\n\n  const url \u003d\n    `https://storage.googleapis.com/upload/storage/v1/b/${bucket}/o` +\n    `?uploadType\u003dmedia\u0026name\u003d${enc}` +\n    (ifGenerationMatch ? `\u0026ifGenerationMatch\u003d${encodeURIComponent(ifGenerationMatch)}` : \u0027\u0027);\n\n  UrlFetchApp.fetch(url, {\n    method: \u0027post\u0027,\n    contentType: \u0027text/csv\u0027,\n    headers: { Authorization: \u0027Bearer \u0027 + token },\n    payload: csvText,\n    muteHttpExceptions: true\n  });\n}\n\n/** When no leftovers remain: optionally move the last consumed object to /processed and delete live. */\nfunction gcsFinalizeNoLeftovers_(ifGenerationMatch, moveToProcessed) {\n  const token \u003d ScriptApp.getOAuthToken();\n  const bucket \u003d CFG().GCS_BUCKET;\n  const path \u003d CFG().GCS_RESULTS_PATH;\n  const base \u003d `https://storage.googleapis.com/storage/v1/b/${bucket}/o`;\n  const enc \u003d encodeURIComponent(path);\n\n  if (moveToProcessed) {\n    const ts \u003d Utilities.formatDate(new Date(), CFG().CT_TZ, \"yyyy-MM-dd\u0027T\u0027HH-mm-ss\");\n    const dst \u003d encodeURIComponent(path.replace(/(^|\\/)([^\\/]+)$/, `$1processed/$2_${ts}`));\n    // copy (rewriteTo)\n    UrlFetchApp.fetch(`${base}/${enc}/rewriteTo/b/${bucket}/o/${dst}`, {\n      method: \u0027post\u0027,\n      headers: { Authorization: \u0027Bearer \u0027 + token },\n      muteHttpExceptions: true\n    });\n  }\n\n  // delete live (guard on generation when provided)\n  const delUrl \u003d `${base}/${enc}` + (ifGenerationMatch ? `?ifGenerationMatch\u003d${encodeURIComponent(ifGenerationMatch)}` : \u0027\u0027);\n  UrlFetchApp.fetch(delUrl, {\n    method: \u0027delete\u0027,\n    headers: { Authorization: \u0027Bearer \u0027 + token },\n    muteHttpExceptions: true\n  });\n}\n\n/** Minimal CSV serializer (quotes cells containing comma, quote, CR/LF). */\nfunction csvFromRows_(rows) {\n  function esc(s) {\n    s \u003d (s \u003d\u003d\u003d null || s \u003d\u003d\u003d undefined) ? \u0027\u0027 : String(s);\n    if (/[\",\\r\\n]/.test(s)) {\n      return \u0027\"\u0027 + s.replace(/\"/g, \u0027\"\"\u0027) + \u0027\"\u0027;\n    }\n    return s;\n  }\n  return rows.map(r \u003d\u003e (r || []).map(esc).join(\u0027,\u0027)).join(\u0027\\n\u0027);\n}\n\n/** Download latest webhook CSV (GCS) and rotate it into processed path. */\nfunction gcsDownloadAndRotate_() {\n  const token \u003d ScriptApp.getOAuthToken();\n  const bucket \u003d CFG().GCS_BUCKET, path \u003d CFG().GCS_RESULTS_PATH;\n  const base \u003d `https://storage.googleapis.com/storage/v1/b/${bucket}/o`;\n  const enc \u003d encodeURIComponent(path);\n\n  // exist?\n  const meta \u003d UrlFetchApp.fetch(`${base}/${enc}?fields\u003dsize`, {\n    headers: { Authorization: \u0027Bearer \u0027 + token },\n    muteHttpExceptions: true\n  });\n  if (meta.getResponseCode() !\u003d\u003d 200) return null;\n\n  // download\n  const media \u003d UrlFetchApp.fetch(`${base}/${enc}?alt\u003dmedia`, {\n    headers: { Authorization: \u0027Bearer \u0027 + token }\n  });\n  const blob \u003d media.getBlob();\n\n  // archive copy\n  const ts \u003d Utilities.formatDate(new Date(), CFG().CT_TZ, \"yyyy-MM-dd\u0027T\u0027HH-mm-ss\");\n  const arc \u003d encodeURIComponent(path.replace(/(^|\\/)([^\\/]+)$/, `$1processed/$2_${ts}`));\n  UrlFetchApp.fetch(`${base}/${enc}/rewriteTo/b/${bucket}/o/${arc}`, {\n    method: \u0027post\u0027,\n    headers: { Authorization: \u0027Bearer \u0027 + token }\n  });\n\n  // delete live\n  UrlFetchApp.fetch(`${base}/${enc}`, {\n    method: \u0027delete\u0027,\n    headers: { Authorization: \u0027Bearer \u0027 + token }\n  });\n\n  return blob;\n}\n\n/** Next Call Date logic */\nfunction computeNextCallDate_(dateStr, correctName, runTag) {\n  if (!dateStr) return \u0027\u0027;\n  const base \u003d new Date(dateStr);\n  const runN \u003d (String(runTag || \u0027\u0027).match(/(\\d+)/) || [])[1] ? Number(RegExp.$1) : 1;\n  let days;\n  const cn \u003d (correctName || \u0027\u0027).toLowerCase();\n  \n  const STATUS_GROUP_5D \u003d [\u0027voicemail - no name\u0027, \u0027voicemail - correct name\u0027, \u0027no answer\u0027, \n                           \u0027voicemail - company name only\u0027, \u0027voicemail_reached\u0027, \u0027dial_no_answer\u0027, \u0027\u0027];\n  const STATUS_GROUP_30D \u003d [\"prospect reached\"];\n  \n  if (STATUS_GROUP_5D.some(s \u003d\u003e cn.includes(s))) days \u003d (runN \u003e\u003d 5 ? 30 : 5);\n  else if (STATUS_GROUP_30D.some(s \u003d\u003e cn.includes(s))) days \u003d (runN \u003e\u003d 5 ? 60 : 30);\n  else days \u003d (runN \u003e\u003d 5 ? 30 : 5); // default behavior\n\n  const next \u003d new Date(base.getTime() + days * 86400000);\n  return Utilities.formatDate(next, CFG().CT_TZ, \u0027yyyy-MM-dd\u0027);\n}\n/** Main webhook ingestion function */\nfunction hubIngestWebhooks_() {\n  const P \u003d PropertiesService.getScriptProperties();\n  const startTime \u003d Number(P.getProperty(\u0027WEBHOOK_POLL_START_TIME\u0027) || 0);\n  const triggerId \u003d P.getProperty(\u0027WEBHOOK_POLL_TRIGGER_ID\u0027);\n\n  if (startTime \u0026\u0026 triggerId) {\n    const elapsedMinutes \u003d (Date.now() - startTime) / (1000 * 60);\n    if (elapsedMinutes \u003e 90) {\n      console.log(`Webhook polling has been active for over 90 minutes. Deleting trigger ID: ${triggerId}`);\n\n      // Find and delete this specific trigger\n      const allTriggers \u003d ScriptApp.getProjectTriggers();\n      for (const trigger of allTriggers) {\n        if (trigger.getUniqueId() \u003d\u003d\u003d triggerId) {\n          ScriptApp.deleteTrigger(trigger);\n          break;\n        }\n      }\n      // Clean up properties\n      P.deleteProperty(\u0027WEBHOOK_POLL_START_TIME\u0027);\n      P.deleteProperty(\u0027WEBHOOK_POLL_TRIGGER_ID\u0027);\n      return { ok: true, message: \u0027Polling stopped after 90 minutes.\u0027 };\n    }\n  }\n  \n  try {\n    const blob \u003d gcsDownloadAndRotate_();\n    if (!blob) {\n      Logger.log(\u0027No CSV found to ingest (gcsDownloadAndRotate_ returned null).\u0027);\n      return { ok: true, message: \u0027No new results to ingest.\u0027 };\n    }\n\n    const csv \u003d blob.getDataAsString(\u0027UTF-8\u0027);\n    const rows \u003d Utilities.parseCsv(csv);\n    if (!rows || rows.length \u003c 2) {\n      Logger.log(\u0027CSV had no data rows.\u0027);\n      return { ok: true, message: \u0027No new results to ingest.\u0027 };\n    }\n\n    const srcHeaders \u003d rows[0];\n    const dataRows \u003d rows.slice(1);\n\n    // Build phone-to-run map from _Sent Index\n    const ssOut \u003d ssById_(CFG().OUTBOUND_SS_ID);\n    const sentIdx \u003d sh_(ssOut, TAB_SENT_INDEX);\n    ensureHeaders_(sentIdx, [\u0027Phone\u0027, \u0027Run\u0027, \u0027BatchTime\u0027]);\n\n    const sentMap \u003d {};\n    if (sentIdx.getLastRow() \u003e 1) {\n      const si \u003d sentIdx.getRange(2, 1, sentIdx.getLastRow() - 1, 3).getValues();\n      si.forEach(r \u003d\u003e {\n        const p \u003d normalizePhone_(r[0]);\n        if (p) sentMap[p] \u003d r[1] || \u0027\u0027;\n      });\n    }\n\n    // Classify rows into Results sheet\n    const placedRes \u003d writeResultsMapped_(srcHeaders, dataRows, sentMap) || { placedPhones: [] };\n    const placedSet \u003d new Set(placedRes.placedPhones || []);\n\n    // Prepare Archive output\n    const archive \u003d ensureMonthlyArchive();\n    Logger.log(`Archive target \u003d\u003e fileId\u003d${archive.id}, sheet\u003d\"Archive\"`);\n\n    const shA \u003d archive.sheet;\n    ensureHeaders_(shA, ARCHIVE_HEADERS);\n\n    const srcMap \u003d _ing_normMap_(srcHeaders);\n    const outRows \u003d [];\n    const recallMap \u003d {};\n\n    const recallCfg \u003d _ing_getRecallDays_(); // { noAnswer, answered }\n\n    for (let i \u003d 0; i \u003c dataRows.length; i++) {\n      const row \u003d dataRows[i] || [];\n      const phone \u003d normalizePhone_(_ing_pick_(row, srcMap, [\u0027phone\u0027, \u0027phonenumber\u0027, \u0027to_number\u0027, \u0027tonumber\u0027]));\n      const date \u003d _ing_pick_(row, srcMap, [\u0027date\u0027]);\n      const runTag \u003d sentMap[phone] || \u0027\u0027;\n      const runNum \u003d _ing_runNumberFromTag_(runTag) || \u0027\u0027;\n\n      const mapped \u003d ARCHIVE_HEADERS.map(h \u003d\u003e {\n        const k \u003d _ing_norm(h);\n        switch (k) {\n          case \u0027date\u0027: return String(date || \u0027\u0027);\n          case \u0027phone\u0027: return String(phone || \u0027\u0027);\n          case \u0027run\u0027: return String(runNum || \u0027\u0027);\n          case \u0027processed\u0027: return \u0027\u0027;\n          case \u0027nextcalldate\u0027: {\n            const ymd \u003d _ing_computeNextCallYMD_(row, srcMap, date, runNum, recallCfg);\n            return ymd || \u0027\u0027;\n          }\n          default:\n            return String(_ing_pick_(row, srcMap, _ing_aliasesArchive_(k)) || \u0027\u0027);\n        }\n      });\n\n      outRows.push(mapped);\n\n      // Only update \"Next Call Date\" if not already placed\n      if (phone \u0026\u0026 !placedSet.has(phone)) {\n        const ymd \u003d _ing_computeNextCallYMD_(row, srcMap, date, runNum, recallCfg);\n        if (ymd) recallMap[phone] \u003d ymd;\n      }\n    }\n\n    if (outRows.length) {\n      const start \u003d shA.getLastRow() + 1;\n      appendArchiveChunked_(shA, outRows);\n      Logger.log(`Archive appended ${outRows.length} row(s) at row ${start}.`);\n    } else {\n      Logger.log(\u0027Archive had 0 rows to append.\u0027);\n    }\n\n    if (Object.keys(recallMap).length) {\n      _ing_setNextCallForPhones_(recallMap);\n    }\n\n    Logger.log(\u0027CSV fully consumed; live file removed (archived to /processed).\u0027);\n    return { ok: true, message: `Successfully ingested ${outRows.length} results.` };\n\n  } catch (e) {\n    console.error(`HUB ERROR in hubIngestWebhooks_: ${e.toString()}`);\n    return { ok: false, error: \u0027Ingestion failed: \u0027 + String(e) };\n  }\n}\n\n/* \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d Ingest helpers (tolerant mapping) \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\n\nfunction _ing_norm(s) { \n  return String(s || \u0027\u0027).toLowerCase().replace(/[^a-z0-9]/g, \u0027\u0027); \n}\n\nfunction _ing_normMap_(headers) { \n  const m \u003d {}; \n  (headers || []).forEach((h, i) \u003d\u003e m[_ing_norm(h)] \u003d i); \n  return m; \n}\n\nfunction _ing_pick_(row, m, cands) {\n  for (let i \u003d 0; i \u003c cands.length; i++) {\n    const idx \u003d m[_ing_norm(cands[i])];\n    if (typeof idx \u003d\u003d\u003d \u0027number\u0027 \u0026\u0026 idx \u003e\u003d 0) {\n      const v \u003d row[idx];\n      if (v !\u003d\u003d \u0027\u0027 \u0026\u0026 v !\u003d\u003d null \u0026\u0026 v !\u003d\u003d undefined) return v;\n    }\n  }\n  return \u0027\u0027;\n}\n\nfunction _ing_aliasesArchive_(targetNorm) {\n  const A \u003d {\n    \u0027firstname\u0027: [\u0027first name\u0027, \u0027firstname\u0027, \u0027first\u0027],\n    \u0027lastname\u0027: [\u0027last name\u0027, \u0027lastname\u0027, \u0027last\u0027],\n    \u0027address\u0027: [\u0027address\u0027],\n    \u0027city\u0027: [\u0027city\u0027],\n    \u0027inputstate\u0027: [\u0027input state\u0027, \u0027inputstate\u0027, \u0027stateinput\u0027],\n    \u0027stategiven\u0027: [\u0027state given\u0027, \u0027stategiven\u0027, \u0027_state\u0027],\n    \u0027zip\u0027: [\u0027zip\u0027, \u0027zipcode\u0027, \u0027zip_code\u0027],\n    \u0027inputemail\u0027: [\u0027input email\u0027, \u0027inputemail\u0027, \u0027emailinput\u0027],\n    \u0027emailgiven\u0027: [\u0027email given\u0027, \u0027emailgiven\u0027, \u0027emailprovided\u0027, \u0027_email\u0027],\n    \u0027accredited\u0027: [\u0027accredited\u0027],\n    \u0027interested\u0027: [\u0027interested\u0027],\n    \u0027newinvestments\u0027: [\u0027new investments\u0027, \u0027newinvestments\u0027],\n    \u0027liquidtoinvest\u0027: [\u0027liquid to invest\u0027, \u0027liquidtoinvest\u0027, \u0027money\u0027, \u0027liquid\u0027],\n    \u0027pastexperience\u0027: [\u0027past experience\u0027, \u0027past oil\u0027, \u0027pastoil\u0027],\n    \u0027job\u0027: [\u0027job\u0027],\n    \u0027followup\u0027: [\u0027follow up\u0027, \u0027followup\u0027, \u0027follow_up\u0027],\n    \u0027summary\u0027: [\u0027summary\u0027, \u0027summery\u0027],  // tolerate misspelling\n    \u0027quality\u0027: [\u0027quality\u0027],\n    \u0027recording\u0027: [\u0027recording\u0027, \u0027recordingurl\u0027, \u0027recording_url\u0027],\n    \u0027calltime\u0027: [\u0027call time\u0027, \u0027calltime\u0027, \u0027call_duration\u0027, \u0027duration\u0027],\n    \u0027correctname\u0027: [\u0027correct name\u0027, \u0027correctname\u0027, \u0027correct_name\u0027, \u0027status\u0027],\n    \u0027dnc\u0027: [\u0027dnc\u0027, \u0027do_not_call\u0027],\n    \u0027disconnectionreason\u0027: [\u0027disconnection reason\u0027, \u0027disconnectionreason\u0027, \u0027reason\u0027],\n    // pass-throughs:\n    \u0027date\u0027: [\u0027date\u0027],\n    \u0027phone\u0027: [\u0027phone\u0027, \u0027phonenumber\u0027, \u0027to_number\u0027, \u0027tonumber\u0027],\n    \u0027run\u0027: [\u0027run\u0027],\n    \u0027nextcalldate\u0027: [] // computed\n  };\n  const list \u003d A[targetNorm] || [];\n  if (!list.includes(targetNorm)) list.push(targetNorm);\n  return list;\n}\n\nfunction _ing_runNumberFromTag_(tag) {\n  if (!tag) return \u0027\u0027;\n  const m \u003d String(tag).match(/(\\d+)/);\n  return m ? m[1] : \u0027\u0027;\n}\n\nfunction _ing_fmtYMD_(d, tz) { \n  return Utilities.formatDate(d, tz || (CFG().CT_TZ || \u0027America/Chicago\u0027), \u0027yyyy-MM-dd\u0027); \n}\n\n/** Read client-configurable recall days */\nfunction _ing_getRecallDays_() {\n  try {\n    const ss \u003d ssById_(CFG().OUTBOUND_SS_ID);\n    const sh \u003d ss.getSheetByName(\u0027Credit\u0027);\n    if (!sh) return { noAnswer: 5, answered: 30 };\n    const read \u003d a1 \u003d\u003e { \n      try { \n        return Number(sh.getRange(a1).getValue() || 0) \n      } catch (_) { \n        return 0; \n      } \n    };\n    // NEW order: prefer I4/I6, then J4/J6, then legacy I3/I5\n    const noAns \u003d read(\u0027I4\u0027) || read(\u0027J4\u0027) || read(\u0027I3\u0027) || 5;\n    const ans \u003d read(\u0027I6\u0027) || read(\u0027J6\u0027) || read(\u0027I5\u0027) || 30;\n    return { noAnswer: noAns, answered: ans };\n  } catch (_) { \n    return { noAnswer: 5, answered: 30 }; \n  }\n}\n\n/** Decide recall days \u0026 produce yyyy-MM-dd (or \u0027\u0027 if no recall) */\nfunction _ing_computeNextCallYMD_(row, srcMap, dateStr, runNum, cfg) {\n  const tz \u003d CFG().CT_TZ || \u0027America/Chicago\u0027;\n  const base \u003d dateStr ? new Date(dateStr) : new Date();\n  const dis \u003d String(_ing_pick_(row, srcMap, [\u0027disconnectionreason\u0027, \u0027reason\u0027]) || \u0027\u0027).toLowerCase();\n  const corr \u003d String(_ing_pick_(row, srcMap, [\u0027correctname\u0027, \u0027status\u0027]) || \u0027\u0027).toLowerCase();\n  const q \u003d String(_ing_pick_(row, srcMap, [\u0027quality\u0027]) || \u0027\u0027).toLowerCase();\n  const dnc \u003d String(_ing_pick_(row, srcMap, [\u0027dnc\u0027]) || \u0027\u0027).toLowerCase() \u003d\u003d\u003d \u0027true\u0027;\n  if (dnc) return \u0027\u0027; // never recall\n\n  // No-answer bucket (5d by default)\n  const noAnsKeys \u003d [\u0027dial_no_answer\u0027, \u0027no_answer\u0027, \u0027busy\u0027, \u0027voicemail\u0027, \u0027vm\u0027, \u0027ringout\u0027, \u0027not_available\u0027, \u0027ivr\u0027];\n  if (noAnsKeys.some(k \u003d\u003e dis.includes(k))) {\n    const d \u003d new Date(base.getTime() + (cfg.noAnswer * 86400000));\n    return _ing_fmtYMD_(d, tz);\n  }\n\n  // Answered but later (30d by default)\n  const laterKeys \u003d [\u0027later\u0027, \u0027call back\u0027, \u0027follow up\u0027, \u0027not now\u0027, \u0027vacation\u0027, \u0027busy later\u0027, \u0027check back\u0027];\n  if (laterKeys.some(k \u003d\u003e corr.includes(k))) {\n    const d \u003d new Date(base.getTime() + (cfg.answered * 86400000));\n    return _ing_fmtYMD_(d, tz);\n  }\n\n  // Fallback: use call time if present\n  const ct \u003d Number(_ing_pick_(row, srcMap, [\u0027calltime\u0027]) || 0);\n  const days \u003d ct \u003e 0 ? cfg.answered : cfg.noAnswer;\n  const d \u003d new Date(base.getTime() + (days * 86400000));\n  return _ing_fmtYMD_(d, tz);\n}\n\n/** Update Outbound Leads → Next Call for a set of phones */\nfunction _ing_setNextCallForPhones_(recallMap) {\n  const ss \u003d ssById_(CFG().OUTBOUND_SS_ID);\n  const sh \u003d ss.getSheetByName(\u0027Outbound Leads\u0027);\n  if (!sh) return;\n\n  const lastR \u003d sh.getLastRow(), lastC \u003d sh.getLastColumn();\n  if (lastR \u003c 2 || lastC \u003c 1) return;\n  const vals \u003d sh.getRange(1, 1, lastR, lastC).getValues();\n  const headers \u003d vals.shift();\n  const H \u003d {}; \n  headers.forEach((h, i) \u003d\u003e H[String(h).trim().toLowerCase()] \u003d i);\n  const pCol \u003d H[\u0027phone\u0027];\n  let nCol \u003d H[\u0027next call\u0027];\n  if (pCol \u003d\u003d null) return;\n\n  // create Next Call column if missing\n  if (nCol \u003d\u003d null) {\n    sh.insertColumnAfter(lastC);\n    nCol \u003d lastC; // new column index (0-based in our headers map)\n    sh.getRange(1, lastC + 1, 1, 1).setValue(\u0027Next Call\u0027);\n  }\n\n  // Build phone -\u003e 1-based row map\n  const map \u003d {};\n  for (let r \u003d 0; r \u003c vals.length; r++) {\n    const norm \u003d normalizePhone_(vals[r][pCol]);\n    if (norm) map[norm] \u003d r + 2;\n  }\n\n  const updates \u003d [];\n  Object.keys(recallMap).forEach(ph \u003d\u003e {\n    const ri \u003d map[normalizePhone_(ph)];\n    if (ri) updates.push({ row: ri, ymd: recallMap[ph] });\n  });\n\n  // Write in contiguous blocks\n  updates.sort((a, b) \u003d\u003e a.row - b.row);\n  let i \u003d 0;\n  while (i \u003c updates.length) {\n    const start \u003d updates[i].row;\n    let end \u003d start;\n    let j \u003d i + 1;\n    const block \u003d [updates[i].ymd];\n    while (j \u003c updates.length \u0026\u0026 updates[j].row \u003d\u003d\u003d end + 1) { \n      end \u003d updates[j].row; \n      block.push(updates[j].ymd); \n      j++; \n    }\n    sh.getRange(start, nCol + 1, block.length, 1).setValues(block.map(v \u003d\u003e [v]));\n    i \u003d j;\n  }\n}\n/* \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\n/* \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d RESULTS (exact mapping) \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\n/* \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\n\n// Exact client Results order (25 columns)\nconst TARGET_RESULTS_HEADERS \u003d [\n  \u0027Date\u0027, \u0027First Name\u0027, \u0027Last Name\u0027, \u0027Phone\u0027, \u0027Address\u0027, \u0027City\u0027, \u0027Input State\u0027, \u0027State Given\u0027, \u0027Zip\u0027,\n  \u0027Input Email\u0027, \u0027Email Given\u0027, \u0027Accredited\u0027, \u0027Interested\u0027, \u0027New Investments\u0027, \u0027Liquid To Invest\u0027,\n  \u0027Job\u0027, \u0027Follow Up\u0027, \u0027Summery\u0027, \u0027Quality\u0027, \u0027Recording\u0027, \u0027Call Time\u0027, \u0027Correct Name\u0027, \u0027DNC\u0027,\n  \u0027Disconnection Reason\u0027, \u0027Run\u0027\n];\n\n// Normalize header label → compare (case/whitespace/punct insensitive)\nfunction _normKey_(s) { \n  return String(s || \u0027\u0027).toLowerCase().replace(/[^a-z0-9]/g, \u0027\u0027); \n}\n\n// Build src header → index map\nfunction _buildSrcMap_(headers) {\n  const m \u003d {};\n  headers.forEach((h, i) \u003d\u003e { \n    m[_normKey_(h)] \u003d i; \n  });\n  return m;\n}\n\n// Aliases for tolerant matching (normalized keys)\nfunction _aliases_(targetNorm) {\n  const A \u003d {\n    \u0027date\u0027: [\u0027date\u0027],\n    \u0027firstname\u0027: [\u0027firstname\u0027, \u0027first\u0027],\n    \u0027lastname\u0027: [\u0027lastname\u0027, \u0027last\u0027],\n    \u0027phone\u0027: [\u0027phone\u0027, \u0027phonenumber\u0027, \u0027to_number\u0027, \u0027tonumber\u0027],\n    \u0027address\u0027: [\u0027address\u0027],\n    \u0027city\u0027: [\u0027city\u0027],\n    \u0027inputstate\u0027: [\u0027inputstate\u0027, \u0027stateinput\u0027],\n    \u0027stategiven\u0027: [\u0027stategiven\u0027, \u0027_state\u0027],\n    \u0027zip\u0027: [\u0027zip\u0027, \u0027zipcode\u0027, \u0027zip_code\u0027],\n    \u0027inputemail\u0027: [\u0027inputemail\u0027, \u0027emailinput\u0027],\n    \u0027emailgiven\u0027: [\u0027emailgiven\u0027, \u0027_email\u0027, \u0027emailprovided\u0027],\n    \u0027accredited\u0027: [\u0027accredited\u0027],\n    \u0027interested\u0027: [\u0027interested\u0027],\n    \u0027newinvestments\u0027: [\u0027newinvestments\u0027],\n    \u0027liquidtoinvest\u0027: [\u0027liquidtoinvest\u0027, \u0027liquid\u0027, \u0027liquid_to_invest\u0027],\n    \u0027job\u0027: [\u0027job\u0027],\n    \u0027followup\u0027: [\u0027followup\u0027, \u0027follow_up\u0027],\n    \u0027summery\u0027: [\u0027summery\u0027, \u0027summary\u0027],\n    \u0027quality\u0027: [\u0027quality\u0027],\n    \u0027recording\u0027: [\u0027recording\u0027, \u0027recordingurl\u0027, \u0027recording_url\u0027],\n    \u0027calltime\u0027: [\u0027calltime\u0027, \u0027call_time\u0027],\n    \u0027correctname\u0027: [\u0027correctname\u0027, \u0027correct_name\u0027],\n    \u0027dnc\u0027: [\u0027dnc\u0027],\n    \u0027disconnectionreason\u0027: [\u0027disconnectionreason\u0027, \u0027disconnection_reason\u0027],\n    \u0027run\u0027: [\u0027run\u0027, \u0027runnumber\u0027, \u0027run_number\u0027, \u0027status\u0027]\n  };\n  const list \u003d A[targetNorm] || [];\n  if (!list.includes(targetNorm)) list.push(targetNorm);\n  return list;\n}\n\n// Pick first non-empty by candidates (stringified)\nfunction _pick_(row, srcMap, cands) {\n  for (let i \u003d 0; i \u003c cands.length; i++) {\n    const idx \u003d srcMap[cands[i]];\n    if (typeof idx \u003d\u003d\u003d \u0027number\u0027 \u0026\u0026 idx \u003e\u003d 0) {\n      const v \u003d row[idx];\n      if (v !\u003d\u003d \u0027\u0027 \u0026\u0026 v !\u003d\u003d null \u0026\u0026 v !\u003d\u003d undefined) return String(v);\n    }\n  }\n  return \u0027\u0027;\n}\n\n// Derive run if needed (Status like \"Run 3\" → \"3\")\nfunction _deriveRun_(row, srcMap, fallbackRunTag) {\n  if (fallbackRunTag) {\n    const m \u003d String(fallbackRunTag).match(/(\\d+)/);\n    if (m) return m[1];\n  }\n  const v \u003d _pick_(row, srcMap, [\u0027run\u0027, \u0027runnumber\u0027, \u0027run_number\u0027]);\n  if (v) { \n    const m \u003d String(v).match(/(\\d+)/); \n    return m ? m[1] : String(v); \n  }\n  const status \u003d _pick_(row, srcMap, [\u0027status\u0027]);\n  if (status) { \n    const m \u003d String(status).match(/run\\s*(\\d+)/i); \n    if (m) return m[1]; \n  }\n  return \u0027\u0027;\n}\n\n// Ensure destination Results tab exists with EXACT headers\nfunction _ensureResultsSheet_() {\n  const P \u003d PropertiesService.getScriptProperties();\n  const resultsId \u003d P.getProperty(\u0027RESULTS_SS_ID\u0027) || (typeof OUTBOUND_SS_ID !\u003d\u003d \u0027undefined\u0027 ? OUTBOUND_SS_ID : \u0027\u0027);\n  const resultsTab \u003d P.getProperty(\u0027RESULTS_TAB_NAME\u0027) || \u0027Results\u0027;\n  if (!resultsId) throw new Error(\u0027RESULTS_SS_ID not set (or OUTBOUND_SS_ID missing)\u0027);\n  const ss \u003d SpreadsheetApp.openById(resultsId);\n  let sh \u003d ss.getSheetByName(resultsTab);\n  if (!sh) sh \u003d ss.insertSheet(resultsTab);\n\n  // Make sure header row is exactly the target\n  if (sh.getMaxColumns() \u003c TARGET_RESULTS_HEADERS.length) {\n    sh.insertColumnsAfter(sh.getMaxColumns(), TARGET_RESULTS_HEADERS.length - sh.getMaxColumns());\n  }\n  sh.getRange(1, 1, 1, TARGET_RESULTS_HEADERS.length).setValues([TARGET_RESULTS_HEADERS]);\n  return sh;\n}\n\nfunction writeResultsMapped_(srcHeaders, dataRows, sentMap) {\n  const P \u003d PropertiesService.getScriptProperties();\n  const id \u003d P.getProperty(\u0027RESULTS_SS_ID\u0027);\n  if (!id) throw new Error(\u0027RESULTS_SS_ID not set\u0027);\n  const ss \u003d SpreadsheetApp.openById(id);\n\n  // Load the lists from Results (or from LEAD_LISTS_SS_ID if set)\n  const listsSS \u003d _listsSpreadsheet_();\n  const BAD_LIST_TAB \u003d \u0027Bad Leads\u0027;\n  const NI_LIST_TAB \u003d \u0027Not Interested Leads\u0027;\n\n  const badListPhones \u003d _getPhoneSetFromSheet_(listsSS, BAD_LIST_TAB);\n  const notIntPhones \u003d _getPhoneSetFromSheet_(listsSS, NI_LIST_TAB);\n\n  const srcMap \u003d _buildSrcMap_(srcHeaders);\n  const placed \u003d new Set();\n\n  const buckets \u003d {\n    \"Good Leads\": [],\n    \"Good Leads For Later\": [],\n    \"Bad Leads\": [],\n    \"Not Interested Leads\": []\n  };\n\n  for (let i \u003d 0; i \u003c dataRows.length; i++) {\n    const row \u003d dataRows[i] || [];\n\n    const phone \u003d normalizePhone_(_pick_(row, srcMap, [\u0027phone\u0027, \u0027to_number\u0027, \u0027tonumber\u0027, \u0027phonenumber\u0027]));\n    const runTag \u003d sentMap[phone] || \u0027\u0027;\n    const mapped \u003d TARGET_RESULTS_HEADERS.map(key \u003d\u003e {\n      const norm \u003d _normKey_(key);\n      if (norm \u003d\u003d\u003d \u0027run\u0027) return _deriveRun_(row, srcMap, runTag);\n      if (norm \u003d\u003d\u003d \u0027phone\u0027) return phone;\n      return _pick_(row, srcMap, _aliases_(norm));\n    });\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d CLASSIFICATION \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    (function() {\n      // Priority: Bad List \u003e Not Interested List \u003e Good / Good Later\n      if (phone \u0026\u0026 badListPhones.has(phone)) {\n        buckets[\u0027Bad Leads\u0027].push(mapped);\n        placed.add(phone);\n        return;\n      }\n      if (phone \u0026\u0026 notIntPhones.has(phone)) {\n        buckets[\u0027Not Interested Leads\u0027].push(mapped);\n        placed.add(phone);\n        return;\n      }\n\n      // Classification logic\n      const normalize \u003d (val) \u003d\u003e String(val || \u0027\u0027).trim().toLowerCase().replace(/\\s+/g, \u0027 \u0027);\n\n      // Get all relevant fields and normalize them once\n      const disconnectionReason \u003d normalize(_pick_(row, srcMap, _aliases_(\u0027disconnectionreason\u0027)));\n      const correctName \u003d normalize(_pick_(row, srcMap, _aliases_(\u0027correctname\u0027)));\n      const callTime \u003d Number(_pick_(row, srcMap, _aliases_(\u0027calltime\u0027)) || 0);\n      const quality \u003d normalize(_pick_(row, srcMap, _aliases_(\u0027quality\u0027)));\n      const interested \u003d normalize(_pick_(row, srcMap, _aliases_(\u0027interested\u0027)));\n      const liquidToInvest \u003d normalize(_pick_(row, srcMap, _aliases_(\u0027liquidtoinvest\u0027)));\n      const newInvestments \u003d normalize(_pick_(row, srcMap, _aliases_(\u0027newinvestments\u0027)));\n      const emailGiven \u003d String(_pick_(row, srcMap, _aliases_(\u0027emailgiven\u0027)) || \u0027\u0027).trim();\n      const summary \u003d normalize(_pick_(row, srcMap, _aliases_(\u0027summery\u0027))); // \u0027summery\u0027 alias handles \u0027summary\u0027\n\n      let target \u003d null;\n\n      // --- Keyword Sets for Checks ---\n      const badLeadDisconnectReasons \u003d new Set([\u0027max_duration_reached\u0027, \u0027dial_failed\u0027, \u0027error_no_audio_received\u0027, \u0027dial_busy\u0027, \u0027invalid_destination\u0027]);\n      const badLeadCorrectNameKeywords \u003d [\u0027wrong number\u0027, \u0027phone directory / ivr\u0027, \u0027gatekeeper\u0027, \u0027fax line\u0027, \u0027voicemail - wrong name\u0027, \u0027disconnected number\u0027];\n      const positiveInterestKeywords \u003d new Set([\u0027yes\u0027, \u0027true\u0027, \u0027y\u0027, \u00271\u0027]);\n      const liquidInvestKeywords \u003d new Set([\u0027yes\u0027, \u0027true\u0027, \u0027y\u0027, \u00271\u0027, \u0027false\u0027]);\n\n      // --- Classification Logic with Priorities ---\n\n      // Priority 1: Bad Leads\n      const isBadDisconnect \u003d badLeadDisconnectReasons.has(disconnectionReason);\n      const isBadCorrectName \u003d badLeadCorrectNameKeywords.some(keyword \u003d\u003e correctName.includes(keyword));\n\n      if (isBadDisconnect || isBadCorrectName) {\n        target \u003d \u0027Bad Leads\u0027;\n      }\n      // Priority 2: Good Leads For Later\n      else if (\n        correctName.includes(\u0027prospect reached\u0027) \u0026\u0026\n        callTime \u003e 30 \u0026\u0026\n        (quality \u003d\u003d\u003d \u0027good\u0027 || quality \u003d\u003d\u003d \u0027unsure\u0027) \u0026\u0026\n        positiveInterestKeywords.has(interested) \u0026\u0026\n        !liquidInvestKeywords.has(liquidToInvest) \u0026\u0026\n        (newInvestments.includes(\u0027later\u0027) || emailGiven !\u003d\u003d \u0027\u0027)\n      ) {\n        target \u003d \u0027Good Leads For Later\u0027;\n      }\n      // Priority 3: Good Leads\n      else if (\n        correctName.includes(\u0027prospect reached\u0027) \u0026\u0026\n        callTime \u003e 30 \u0026\u0026\n        (quality \u003d\u003d\u003d \u0027good\u0027 || quality \u003d\u003d\u003d \u0027unsure\u0027) \u0026\u0026\n        positiveInterestKeywords.has(interested) \u0026\u0026\n        (newInvestments \u003d\u003d\u003d \u0027now\u0027 || emailGiven !\u003d\u003d \u0027\u0027)\n      ) {\n        target \u003d \u0027Good Leads\u0027;\n      }\n      // Priority 4: Not Interested Leads\n      else if (\n        callTime \u003e 20 \u0026\u0026\n        correctName.includes(\u0027prospect reached\u0027) \u0026\u0026\n        !newInvestments.includes(\u0027later\u0027) \u0026\u0026 !newInvestments.includes(\u0027now\u0027) \u0026\u0026\n        emailGiven \u003d\u003d\u003d \u0027\u0027 \u0026\u0026\n        (!positiveInterestKeywords.has(interested) || summary.includes(\u0027not interested\u0027))\n      ) {\n        target \u003d \u0027Not Interested Leads\u0027;\n      }\n\n      if (target) {\n        buckets[target].push(mapped);\n        if (phone) placed.add(phone);\n      }\n      // NOTE: Everything else (not in any bucket) will be handled by recall logic.\n    })();\n  }\n\n  // Write out tabs (ensuring headers)\n  Object.keys(buckets).forEach(tab \u003d\u003e {\n    if (!buckets[tab].length) return;\n    let sh \u003d ss.getSheetByName(tab);\n    if (!sh) sh \u003d ss.insertSheet(tab);\n    sh.getRange(1, 1, 1, TARGET_RESULTS_HEADERS.length).setValues([TARGET_RESULTS_HEADERS]);\n    const startRow \u003d sh.getLastRow() + 1;\n    sh.getRange(startRow, 1, buckets[tab].length, TARGET_RESULTS_HEADERS.length).setValues(buckets[tab]);\n  });\n\n  return { placedPhones: Array.from(placed) };\n}"},{"id":"1b0186ad-5c4e-4243-b071-2ba00549abad","name":"Hub_Config","type":"server_js","source":"// Hub_Config.js - Central configuration\n// This file defines all configuration constants and retrieval functions\n\n/** Central config pulled from Script Properties */\nfunction CFG() {\n  const P \u003d PropertiesService.getScriptProperties();\n  const v \u003d k \u003d\u003e P.getProperty(k) || \u0027\u0027;\n  const i \u003d k \u003d\u003e parseInt(P.getProperty(k) || \u00270\u0027, 10);\n  return {\n    FOLDER_ID:        v(\u0027FOLDER_ID\u0027),\n    OUTBOUND_SS_ID:   v(\u0027OUTBOUND_SS_ID\u0027),\n    RESULTS_SS_ID:    v(\u0027RESULTS_SS_ID\u0027),\n    RETELL_API_KEY:   v(\u0027RETELL_API_KEY\u0027),\n    RETELL_URL:       v(\u0027RETELL_URL\u0027) || \u0027https://api.retellai.com/create-batch-call\u0027, // Default URL\n    \n    AGENT: {\n      1: v(\u0027AGENT_RUN_1\u0027),\n      2: v(\u0027AGENT_RUN_2\u0027),\n      3: v(\u0027AGENT_RUN_3\u0027),\n      4: v(\u0027AGENT_RUN_4\u0027),\n      5: v(\u0027AGENT_RUN_5\u0027),\n      6: v(\u0027AGENT_RUN_6\u0027),\n      7: v(\u0027AGENT_RUN_7\u0027),\n      8: v(\u0027AGENT_RUN_8\u0027)\n    },\n    FROM: {\n      1: v(\u0027FROM_RUN_1\u0027),\n      2: v(\u0027FROM_RUN_2\u0027),\n      3: v(\u0027FROM_RUN_3\u0027),\n      4: v(\u0027FROM_RUN_4\u0027),\n      5: v(\u0027FROM_RUN_5\u0027),\n      6: v(\u0027FROM_RUN_6\u0027),\n      7: v(\u0027FROM_RUN_7\u0027),\n      8: v(\u0027FROM_RUN_8\u0027)\n    },\n    CLIENT_TOKEN:      v(\u0027CLIENT_TOKEN\u0027),\n    PORTAL_PASSWORD:   v(\u0027PORTAL_PASSWORD\u0027),\n    GCS_BUCKET:        v(\u0027GCS_BUCKET\u0027) || \u0027vista-retell-calling-reference-data\u0027,\n    GCS_RESULTS_PATH:  v(\u0027GCS_RESULTS_PATH\u0027) || \u0027raw_leads/inbound_webhook_vista.csv\u0027,\n    MAX_PER_RUN:       i(\u0027MAX_PER_RUN\u0027) || 1000,\n    DEFAULT_RUN_LIMIT: i(\u0027DEFAULT_RUN_LIMIT\u0027) || i(\u0027MAX_PER_RUN\u0027) || 1000,\n    CT_TZ:             v(\u0027CT_TZ\u0027) || \u0027America/Chicago\u0027,\n    INGEST_COOLDOWN_MIN: i(\u0027INGEST_COOLDOWN_MIN\u0027) || 20\n  };\n}\n\n/** Constants for recall rules */\nconst STATUS_GROUP_5D  \u003d [\n  \u0027voicemail - no name\u0027, \n  \u0027voicemail - correct name\u0027, \n  \u0027no answer\u0027, \n  \u0027voicemail - company name only\u0027,\n  \u0027voicemail_reached\u0027,\n  \u0027dial_no_answer\u0027,\n  \u0027\u0027\n]; \n\nconst STATUS_GROUP_30D \u003d [\"prospect reached\"];\n\n/** Archive naming */\nfunction archiveNameFor_(d) {\n  const month \u003d Utilities.formatDate(d, CFG().CT_TZ, \u0027MMMM yyyy\u0027);\n  return `Archive - ${month}`;\n}\n\n/** Canonical headers for Archive sheets */\nconst ARCHIVE_HEADERS \u003d [\n  \u0027Date\u0027, \u0027First Name\u0027, \u0027Last Name\u0027, \u0027Phone\u0027, \u0027Address\u0027, \u0027City\u0027,\n  \u0027Input State\u0027, \u0027State Given\u0027, \u0027Zip\u0027, \u0027Input Email\u0027, \u0027Email Given\u0027,\n  \u0027Accredited\u0027, \u0027Interested\u0027, \u0027New Investments\u0027, \u0027Liquid To Invest\u0027,\n  \u0027Past Experience\u0027, \u0027Job\u0027, \u0027Follow Up\u0027, \u0027Summary\u0027, \u0027Quality\u0027,\n  \u0027Recording\u0027, \u0027Call Time\u0027, \u0027Correct Name\u0027, \u0027DNC\u0027, \u0027Disconnection Reason\u0027,\n  \u0027Run\u0027, \u0027Next Call Date\u0027\n];\n\n/** Canonical headers for Results sheets */\nconst RESULTS_HEADERS \u003d [\n  \u0027Date\u0027, \u0027First Name\u0027, \u0027Last Name\u0027, \u0027Phone\u0027, \u0027Address\u0027, \u0027City\u0027,\n  \u0027Input State\u0027, \u0027State Given\u0027, \u0027Zip\u0027, \u0027Input Email\u0027, \u0027Email Given\u0027,\n  \u0027Accredited\u0027, \u0027Interested\u0027, \u0027New Investments\u0027, \u0027Liquid To Invest\u0027,\n  \u0027Past Experience\u0027, \u0027Job\u0027, \u0027Follow Up\u0027, \u0027Summary\u0027, \u0027Quality\u0027,\n  \u0027Recording\u0027, \u0027Call Time\u0027, \u0027Correct Name\u0027, \u0027DNC\u0027, \u0027Disconnection Reason\u0027,\n  \u0027Run\u0027, \u0027Next Call Date\u0027\n];\n\n/** Outbound tab names */\nconst TAB_OUTBOUND \u003d \u0027Outbound Leads\u0027;\nconst TAB_RECYCLE  \u003d \u0027Recycle\u0027;\nconst TAB_CREDIT   \u003d \u0027Credit\u0027;\n\n/** Hidden phone→run index to stamp Run in Archive */\nconst TAB_SENT_INDEX \u003d \u0027_Sent Index\u0027; // hidden; headers: Phone | Run | BatchTime\n\n/** Client UI cooldown (minutes) */\nconst COOLDOWN_MINUTES_CLIENT \u003d 21;\n\n/** Hidden sheet to store last send timestamps */\nconst TAB_RATELIMIT \u003d \u0027_RateLimit\u0027;  // headers: Key | LastAt\n\n// Call window in Central Time (inclusive start, exclusive end)\nconst CT_TZ \u003d (typeof CFG !\u003d\u003d \u0027undefined\u0027 \u0026\u0026 CFG().CT_TZ) ? CFG().CT_TZ : \u0027America/Chicago\u0027;\nconst CALL_START_HOUR_CT \u003d 7;   // 7 AM CT\nconst CALL_END_HOUR_CT   \u003d 20;  // 8 PM CT\n\n// Optional: allow-list specific configurations\nfunction CFG_EXTRA() {\n  const P \u003d PropertiesService.getScriptProperties();\n  return {\n    ALLOWED_SHEET_ID: P.getProperty(\u0027ALLOWED_SHEET_ID\u0027) || \u0027\u0027,\n    ALLOWED_EMAILS: (P.getProperty(\u0027ALLOWED_EMAILS\u0027) || \u0027\u0027).split(\u0027,\u0027).map(s \u003d\u003e s.trim()).filter(Boolean)\n  };\n}"},{"id":"9012d65d-5f35-4e3a-b636-1ec0d155cfba","name":"Hub_Recall","type":"server_js","source":"/** Daily: pull due recalls (Next Call Date \u003c\u003d today \u0026\u0026 Processed blank) into Outbound:Recycle with Run+1 */\nfunction hubSweepRecalls(){\n  // Open current archive file (you can loop previous months too if needed)\n  const {id} \u003d ensureMonthlyArchive();\n  const ssA \u003d ssById_(id);\n  const shA \u003d sh_(ssA, \u0027Archive\u0027); ensureHeaders_(shA, ARCHIVE_HEADERS);\n  const {headers, rows} \u003d getSheetData_(shA);\n  if (!headers.length || !rows.length) return;\n\n  const H \u003d headerMap_(headers); // lower-cased keys\n  const idx \u003d name \u003d\u003e (H[name] !\u003d null ? H[name] : -1);\n\n  const ix \u003d {\n    date: idx(\u0027date\u0027),\n    phone: idx(\u0027phone\u0027),\n    next: idx(\u0027next call date\u0027),\n    run: idx(\u0027run\u0027),\n    processed: idx(\u0027processed\u0027),\n    first: idx(\u0027first name\u0027),\n    last: idx(\u0027last name\u0027),\n    addr: idx(\u0027address\u0027),\n    city: idx(\u0027city\u0027),\n    state: idx(\u0027input state\u0027),\n    stategiven: idx(\u0027state given\u0027),            // ← NEW: prefer this when present\n    zip: idx(\u0027zip\u0027),\n    email: idx(\u0027input email\u0027)\n  };\n\n  const today \u003d Utilities.formatDate(new Date(), CFG().CT_TZ, \u0027yyyy-MM-dd\u0027);\n  const dueRows \u003d rows.filter(r\u003d\u003e{\n    const next \u003d String(r[ix.next]||\u0027\u0027);\n    const proc \u003d String(r[ix.processed]||\u0027\u0027).trim();\n    return next \u0026\u0026 next \u003c\u003d today \u0026\u0026 !proc;\n  });\n\n  if (!dueRows.length) return;\n\n  // Move into Outbound:Recycle with Run+1 (cap at 9)\n  const ssOut \u003d ssById_(CFG().OUTBOUND_SS_ID);\n  const shR   \u003d sh_(ssOut, TAB_RECYCLE);\n  ensureHeaders_(shR, [\u0027First Name\u0027,\u0027Last Name\u0027,\u0027Phone\u0027,\u0027Address\u0027,\u0027City\u0027,\u0027State\u0027,\u0027Zip\u0027,\u0027Email\u0027,\u0027Run\u0027]);\n\n  const append \u003d [];\n  const mark   \u003d [];\n  dueRows.forEach((r)\u003d\u003e{\n    const phone \u003d normalizePhone_(r[ix.phone]);\n    const runN  \u003d (String(r[ix.run]||\u0027\u0027).match(/(\\d+)/) ? Number(RegExp.$1) : 1);\n    const nextRun \u003d Math.min(runN+1, 9);\n\n    // Prefer \"State Given\" over \"Input State\"\n    const stateVal \u003d (ix.stategiven \u003e\u003d 0 ? r[ix.stategiven] : \u0027\u0027) ||\n                     (ix.state      \u003e\u003d 0 ? r[ix.state]      : \u0027\u0027) || \u0027\u0027;\n\n    append.push([\n      r[ix.first]||\u0027\u0027, r[ix.last]||\u0027\u0027, phone, r[ix.addr]||\u0027\u0027, r[ix.city]||\u0027\u0027,\n      stateVal, r[ix.zip]||\u0027\u0027, r[ix.email]||\u0027\u0027, `Run ${nextRun}`\n    ]);\n\n    // mark processed\n    mark.push({row:r, val:`Recycled ${today}`});\n  });\n\n  if (append.length) {\n    shR.getRange(shR.getLastRow()+1,1,append.length,9).setValues(append);\n  }\n\n  // Mark Processed flag in Archive\n  mark.forEach((m)\u003d\u003e{\n    const rowIdx \u003d rows.indexOf(m.row) + 2;\n    shA.getRange(rowIdx, ix.processed+1).setValue(m.val);\n  });\n}\n\n/** Web API: run send by source and run number (called by stub) */\nfunction apiSendRun_(sourceTab, runNumber, limitOverride){\n  return startHubSendRun(sourceTab, runNumber, limitOverride);   // startHubSendRun accepts optional limit\n}"},{"id":"061f3a60-c142-470f-b9c2-09f326b7fd4a","name":"Hub_RemoveRun","type":"server_js","source":"/**\n * Clear Run on Outbound Leads for any phones that appear in Results tabs:\n *  - Not Interested Leads\n *  - Bad Leads\n *  - Good Leads For Later\n *  - Good Leads\n *\n * USAGE:\n *   sweepClassifiedFreezeRuns();  // uses defaults below\n *   // or pass explicit IDs/tabs:\n *   sweepClassifiedFreezeRuns({\n *     resultsId: \u00271fioSXdZqAUKwNUQb0akwST7vKK7QhwU4thnWM7TcJC0\u0027,\n *     outboundId:\u00271zOKYe4lSZDUA8uHjsGSxDavZQspeUok4GEupm4OCO9c\u0027,\n *     tabs: [\u0027Not Interested Leads\u0027,\u0027Bad Leads\u0027,\u0027Good Leads For Later\u0027,\u0027Good Leads\u0027]\n *   });\n */\nfunction sweepClassifiedFreezeRuns(opts) {\n  opts \u003d opts || {};\n  // Defaults from your message\n  var RESULTS_ID  \u003d opts.resultsId  || \u00271fioSXdZqAUKwNUQb0akwST7vKK7QhwU4thnWM7TcJC0\u0027;\n  var OUTBOUND_ID \u003d opts.outboundId || \u00271zOKYe4lSZDUA8uHjsGSxDavZQspeUok4GEupm4OCO9c\u0027;\n  var TABS \u003d opts.tabs || [\u0027Not Interested Leads\u0027,\u0027Bad Leads\u0027,\u0027Good Leads For Later\u0027,\u0027Good Leads\u0027];\n\n  // 1) Collect phones from Results tabs\n  var classifiedSet \u003d collectPhonesFromResults_(RESULTS_ID, TABS);\n\n  // Nothing to do\n  if (!classifiedSet || classifiedSet.size \u003d\u003d\u003d 0) {\n    return {ok:true, scannedTabs:TABS.length, resultsPhones:0, cleared:0};\n  }\n\n  // 2) Open Outbound → Outbound Leads\n  var ssOut \u003d SpreadsheetApp.openById(OUTBOUND_ID);\n  var shOut \u003d ssOut.getSheetByName(\u0027Outbound Leads\u0027);\n  if (!shOut) throw new Error(\u0027Outbound Leads sheet not found in Outbound Console file.\u0027);\n\n  var lastRow \u003d shOut.getLastRow();\n  var lastCol \u003d shOut.getLastColumn();\n  if (lastRow \u003c 2) return {ok:true, scannedTabs:TABS.length, resultsPhones:classifiedSet.size, cleared:0};\n\n  // Find headers (case/space-insensitive)\n  var headers \u003d shOut.getRange(1,1,1,lastCol).getValues()[0];\n  var phoneCol \u003d findHeaderIndexCi_(headers, \u0027phone\u0027); // 1-based\n  var runCol   \u003d findHeaderIndexCi_(headers,  \u0027run\u0027);  // 1-based\n  if (!phoneCol || !runCol) throw new Error(\u0027Missing Phone or Run column on Outbound Leads.\u0027);\n\n  // Read both columns (fast)\n  var phones \u003d shOut.getRange(2, phoneCol, lastRow-1, 1).getValues(); // 2..last\n  var runs   \u003d shOut.getRange(2, runCol,   lastRow-1, 1).getValues();\n\n  // Determine which rows to clear\n  var rowsToClear \u003d [];\n  for (var i\u003d0; i\u003cphones.length; i++) {\n    var norm \u003d normPhone10_(phones[i][0]);\n    if (!norm) continue;\n    if (classifiedSet.has(norm)) {\n      var runVal \u003d String(runs[i][0]||\u0027\u0027).trim();\n      if (runVal) rowsToClear.push(i+2); // convert to 1-based sheet row index, add header offset\n    }\n  }\n  if (rowsToClear.length \u003d\u003d\u003d 0) {\n    return {ok:true, scannedTabs:TABS.length, resultsPhones:classifiedSet.size, cleared:0};\n  }\n\n  // Batch clear Run in contiguous blocks for speed\n  rowsToClear.sort(function(a,b){ return a-b; });\n  var cleared \u003d 0;\n  var idx \u003d 0;\n  while (idx \u003c rowsToClear.length) {\n    var start \u003d rowsToClear[idx];\n    var end \u003d start;\n    var j \u003d idx + 1;\n    while (j \u003c rowsToClear.length \u0026\u0026 rowsToClear[j] \u003d\u003d\u003d end + 1) { end \u003d rowsToClear[j]; j++; }\n    var len \u003d end - start + 1;\n    // Either clearContent() on that single column or set blanks; both are fine.\n    // Using setValues to be explicit about writing only that column.\n    shOut.getRange(start, runCol, len, 1).setValues(new Array(len).fill([\u0027\u0027]));\n    cleared +\u003d len;\n    idx \u003d j;\n  }\n\n  return {ok:true, scannedTabs:TABS.length, resultsPhones:classifiedSet.size, cleared:cleared};\n}\n\n/* ---------- helpers ---------- */\n\n// Read phones from multiple Results tabs into a Set of normalized 10-digit strings\nfunction collectPhonesFromResults_(resultsId, tabNames) {\n  var ss \u003d SpreadsheetApp.openById(resultsId);\n  var set \u003d new Set();\n  for (var t\u003d0; t\u003ctabNames.length; t++) {\n    var name \u003d tabNames[t];\n    var sh \u003d ss.getSheetByName(name);\n    if (!sh) continue;\n    var lastRow \u003d sh.getLastRow(), lastCol \u003d sh.getLastColumn();\n    if (lastRow \u003c 2) continue;\n    var headers \u003d sh.getRange(1,1,1,lastCol).getValues()[0];\n    var pCol \u003d findHeaderIndexCi_(headers, \u0027phone\u0027); // 1-based\n    if (!pCol) continue;\n    var vals \u003d sh.getRange(2, pCol, lastRow-1, 1).getValues();\n    for (var i\u003d0;i\u003cvals.length;i++){\n      var norm \u003d normPhone10_(vals[i][0]);\n      if (norm) set.add(norm);\n    }\n  }\n  return set;\n}\n\n// Case/space-insensitive header finder; returns 1-based column index or 0 if not found\nfunction findHeaderIndexCi_(headers, wanted) {\n  var target \u003d String(wanted).toLowerCase().replace(/\\s+/g,\u0027\u0027);\n  for (var i\u003d0;i\u003cheaders.length;i++){\n    var h \u003d String(headers[i]||\u0027\u0027).toLowerCase().replace(/\\s+/g,\u0027\u0027);\n    if (h \u003d\u003d\u003d target) return i+1;\n  }\n  // loose contains match as a fallback\n  for (var j\u003d0;j\u003cheaders.length;j++){\n    var hh \u003d String(headers[j]||\u0027\u0027).toLowerCase();\n    if (hh.indexOf(String(wanted).toLowerCase()) !\u003d\u003d -1) return j+1;\n  }\n  return 0;\n}\n\n// Normalize phones to strict 10 digits; tolerate +1, punctuation, spaces\nfunction normPhone10_(v) {\n  if (v \u003d\u003d null) return \u0027\u0027;\n  var s \u003d String(v).trim();\n  if (s.startsWith(\u0027\u003d+\u0027)) s \u003d \u0027+\u0027 + s.slice(2); // Excel quirk\n  else if (s.startsWith(\u0027\u003d\u0027)) s \u003d s.slice(1);\n  var d \u003d s.replace(/\\D/g,\u0027\u0027);            // keep digits only\n  if (!d) return \u0027\u0027;\n  if (d.length \u003d\u003d\u003d 11 \u0026\u0026 d[0] \u003d\u003d\u003d \u00271\u0027) d \u003d d.slice(1); // drop leading 1\n  if (d.length \u003e 10) d \u003d d.slice(-10);                 // keep last 10 if longer\n  return (d.length \u003d\u003d\u003d 10) ? d : \u0027\u0027;\n}\n\n/**\n * Wrapper: sweep freeze using Hub config values.\n * Reads OUTBOUND_SS_ID and RESULTS_SS_ID from CFG().\n */\nfunction sweepFreezeUsingCfg_() {\n  const c \u003d CFG();  // your Hub config function\n  return sweepClassifiedFreezeRuns({\n    resultsId:  c.RESULTS_SS_ID,\n    outboundId: c.OUTBOUND_SS_ID,\n    tabs: [\u0027Not Interested Leads\u0027,\u0027Bad Leads\u0027,\u0027Good Leads For Later\u0027,\u0027Good Leads\u0027]\n  });\n}\n"},{"id":"5a2c0b63-60a9-40ff-8dd5-127c14d9abb4","name":"Hub_SenderAndCredits","type":"server_js","source":"/** Credits helpers (stored in Outbound: Credit!B1 and ledger rows under A3:C3) */\nfunction getBalance_(){\n  const ss\u003dssById_(CFG().OUTBOUND_SS_ID); const sh\u003dsh_(ss, TAB_CREDIT);\n  return Number(sh.getRange(\u0027B1\u0027).getValue())||0;\n}\nfunction setBalance_(v){\n  const ss\u003dssById_(CFG().OUTBOUND_SS_ID); const sh\u003dsh_(ss, TAB_CREDIT);\n  sh.getRange(\u0027B1\u0027).setValue(v);\n}\nfunction logCreditMove_(date, sent, refunded){\n  const ss\u003dssById_(CFG().OUTBOUND_SS_ID); const sh\u003dsh_(ss, TAB_CREDIT);\n  if (sh.getLastRow()\u003c3) { sh.getRange(\u0027A3:C3\u0027).setValues([[\u0027Date\u0027,\u0027Calls Sent\u0027,\u0027Credits Refunded\u0027]]); }\n  sh.appendRow([date, sent||0, refunded||0]);\n}\n\n/** Maintain hidden Sent Index */\nfunction appendSentIndex_(phones, run) {\n  const ss \u003d ssById_(CFG().OUTBOUND_SS_ID);\n  const sh \u003d sh_(ss, TAB_SENT_INDEX);\n  ensureHeaders_(sh, [\u0027Phone\u0027,\u0027Run\u0027,\u0027BatchTime\u0027]);\n  sh.hideSheet();\n  const t \u003d Utilities.formatDate(new Date(), CFG().CT_TZ, \"yyyy-MM-dd HH:mm:ss\");\n  \n  // UPDATED: Convert +1XXXXXXXXXX to XXXXXXXXXX for storage\n  const rows \u003d phones.map(p \u003d\u003e {\n    let normalizedPhone \u003d p;\n    // Remove +1 prefix if present\n    if (p.startsWith(\u0027+1\u0027) \u0026\u0026 p.length \u003d\u003d\u003d 12) {\n      normalizedPhone \u003d p.substring(2);  // Remove \u0027+1\u0027\n    } else if (p.startsWith(\u00271\u0027) \u0026\u0026 p.length \u003d\u003d\u003d 11) {\n      normalizedPhone \u003d p.substring(1);   // Remove \u00271\u0027\n    }\n    return [normalizedPhone, `Run ${run}`, t];\n  });\n  \n  if (rows.length) {\n    sh.getRange(sh.getLastRow()+1,1,rows.length,3).setValues(rows);\n  }\n}\n\n/** Build up to MAX_PER_RUN tasks from a given sheet (Outbound Leads or Recycle) */\nfunction collectTasksForRun_(sourceTab, runNumber){\n  const ss \u003d ssById_(CFG().OUTBOUND_SS_ID);\n  const sh \u003d sh_(ss, sourceTab);\n  const {headers, rows} \u003d getSheetData_(sh);\n  if (!headers.length) return {tasks:[], rowsUsed: []};\n\n  const H \u003d headerMap_(headers);\n  const idx \u003d {\n    first: H[\u0027first name\u0027], last: H[\u0027last name\u0027], phone: H[\u0027phone\u0027],\n    addr: H[\u0027address\u0027], city: H[\u0027city\u0027], state: H[\u0027state\u0027], zip: H[\u0027zip\u0027],\n    email: H[\u0027email\u0027], run: H[\u0027run\u0027]\n  };\n  if (idx.phone\u003d\u003dnull) throw new Error(\u0027Phone column missing in \u0027+sourceTab);\n\n  const max \u003d CFG().MAX_PER_RUN;\n  const tasks \u003d [];\n  const rowsUsed \u003d []; // {rowNumber, phone}\n\n  for (let r\u003d0; r\u003crows.length \u0026\u0026 tasks.length\u003cmax; r++){\n    const row \u003d rows[r];\n    const rawRun \u003d (idx.run!\u003dnull ? String(row[idx.run]||\u0027\u0027).trim() : \u0027\u0027);\n    const currentRun \u003d rawRun ? rawRun.replace(/run\\s*/i,\u0027\u0027).trim() : \u0027\u0027;\n    const isBlank \u003d !rawRun;\n\n    // Selection rule: Run1 takes blank or 1; RunN takes N\n    const eligible \u003d (runNumber\u003d\u003d\u003d1 \u0026\u0026 (isBlank || currentRun\u003d\u003d\u003d\u00271\u0027 || /run\\s*1/i.test(rawRun)))\n                  || (runNumber\u003e1 \u0026\u0026 (currentRun\u003d\u003d\u003dString(runNumber) || new RegExp(`run\\\\s*${runNumber}`,\u0027i\u0027).test(rawRun)));\n    if (!eligible) continue;\n\n    const phoneRaw \u003d row[idx.phone];\n    const phone \u003d normalizePhoneE164_(phoneRaw);  // enforce E.164 for Retell\n    if (!phone) continue; // skip rows that can\u0027t normalize\n\n    // Build dynamic variables (strings only; protects zip etc.)\n    const vars \u003d coerceToStringMap_({\n      run: `Run ${runNumber}`,\n      first_name: idx.first!\u003dnull ? row[idx.first] : \u0027\u0027,\n      last_name:  idx.last!\u003dnull  ? row[idx.last]  : \u0027\u0027,\n      address:    idx.addr!\u003dnull  ? row[idx.addr]  : \u0027\u0027,\n      city:       idx.city!\u003dnull  ? row[idx.city]  : \u0027\u0027,\n      state:      idx.state!\u003dnull ? row[idx.state] : \u0027\u0027,\n      zip:        idx.zip!\u003dnull   ? row[idx.zip]   : \u0027\u0027,\n      email:      idx.email!\u003dnull ? row[idx.email] : \u0027\u0027\n    });\n\n    const t \u003d {\n      to_number: phone,\n      agent_id:  CFG().AGENT[runNumber],\n      retell_llm_dynamic_variables: vars\n    };\n    tasks.push(t);\n    rowsUsed.push({rowNumber: r+2, phone});\n  }\n  return {tasks, rowsUsed};\n}\n\nfunction sendLeadViaCF(lead){\n  const {CLOUD_FUNCTION_URL, FROM_NUMBER, AGENT_ID} \u003d CFG();\n  if (!CLOUD_FUNCTION_URL) return false;\n\n  // Belt \u0026 suspenders: enforce shapes here too\n  lead \u003d lead || {};\n  const phone \u003d normalizePhoneE164_(lead.phone || lead.to_number || \u0027\u0027);\n  if (!phone) return false; // don\u0027t send invalid\n  const vars  \u003d coerceToStringMap_(lead.meta || lead.vars || {}); // if you pass any\n\n  try{\n    const res \u003d UrlFetchApp.fetch(CLOUD_FUNCTION_URL, {\n      method:\u0027post\u0027,\n      contentType:\u0027application/json\u0027,\n      muteHttpExceptions:true,\n      payload: JSON.stringify({\n        action:\u0027send_one\u0027,\n        lead: {\n          first_name: lead.first_name || \u0027\u0027,\n          last_name:  lead.last_name  || \u0027\u0027,\n          address:    lead.address    || \u0027\u0027,\n          city:       lead.city       || \u0027\u0027,\n          state:      lead.state      || \u0027\u0027,\n          zip:        String(lead.zip || \u0027\u0027),   // string cast here too\n          email:      lead.email      || \u0027\u0027,\n          phone:      phone,\n          meta:       vars\n        },\n        config: { from_number: FROM_NUMBER, agent_id: AGENT_ID }\n      })\n    });\n    const code \u003d res.getResponseCode();\n    if (code\u003e\u003d200 \u0026\u0026 code\u003c300){\n      const body \u003d JSON.parse(res.getContentText()||\u0027{}\u0027);\n      return !!(body \u0026\u0026 body.ok!\u003d\u003dfalse);\n    }\n    return false;\n  } catch(e){ return false; }\n}\n\n/** Call Retell batch API (create-batch-call). Returns {ok, accepted, message}. */\nfunction sendBatchToRetell_(runNumber, tasks) {\n  if (!tasks.length) return {ok:false, accepted:0, message:\u0027No tasks\u0027};\n\n  // Guard: ensure required per-run config exists\n  const agent \u003d CFG().AGENT[runNumber];\n  const from  \u003d CFG().FROM[runNumber];\n  if (!agent || !from) {\n    return {ok:false, accepted:0, message:`Missing AGENT or FROM for Run ${runNumber}`};\n  }\n\n  const payload \u003d {\n    from_number: from,\n    name: `Batch Run ${runNumber} – ${Utilities.formatDate(new Date(), CFG().CT_TZ, \u0027yyyy-MM-dd HH:mm:ss\u0027)}`,\n    trigger_timestamp: Date.now(),\n    tasks\n  };\n  try{\n    const res \u003d UrlFetchApp.fetch(\u0027https://api.retellai.com/create-batch-call\u0027, {\n      method: \u0027post\u0027,\n      contentType: \u0027application/json\u0027,\n      muteHttpExceptions: true,\n      headers: { \u0027Authorization\u0027: \u0027Bearer \u0027+CFG().RETELL_API_KEY },\n      payload: JSON.stringify(payload)\n    });\n    const code \u003d res.getResponseCode();\n    if (code\u003e\u003d200 \u0026\u0026 code\u003c300) {\n      // Best effort: accept count \u003d tasks length (API may return details; if so, parse here)\n      return {ok:true, accepted:tasks.length, message:\u0027ok\u0027};\n    }\n    return {ok:false, accepted:0, message:`HTTP ${code} - ${res.getContentText()}`};\n  } catch(e){ return {ok:false, accepted:0, message:String(e)}; }\n}\n\n/** Orchestrate a batch send with credit enforcement + stamp Last Call + robust run-bump */\n/** Orchestrate a batch send with credit enforcement (+ optional per-request limit) */\nfunction hubSendRun_(sourceTab, runNumber, limitOverride){\n  const bal \u003d getBalance_();\n  const {tasks, rowsUsed} \u003d collectTasksForRun_(sourceTab, runNumber);\n\n  const perRequest \u003d (limitOverride \u0026\u0026 isFinite(limitOverride)) ? limitOverride : CFG().MAX_PER_RUN;\n  const need \u003d Math.min(tasks.length, perRequest, 1000); // hard cap 1,000\n  if (!need) return {ok:false, error:\u0027No eligible rows found for this run.\u0027};\n  if (bal \u003c need) return {ok:false, error:`INSUFFICIENT_CREDITS: need ${need}, have ${bal}`};\n\n  // Trim\n  const finalRowsUsed \u003d rowsUsed.slice(0, need);         // [{rowNumber, phone}]\n  const finalPhones   \u003d finalRowsUsed.map(x \u003d\u003e x.phone); // E.164\n  const finalTasks    \u003d tasks.slice(0, need);\n\n  // Debit\n  const ts \u003d Utilities.formatDate(new Date(), CFG().CT_TZ, \u0027yyyy-MM-dd HH:mm:ss\u0027);\n  setBalance_(bal - need);\n\n  // Send to Retell\n  const result \u003d sendBatchToRetell_(runNumber, finalTasks);\n  if (!result.ok) {\n    // refund \u0026 log\n    setBalance_(getBalance_() + need);\n    logCreditMove_(ts, 0, need);\n    return {ok:false, error:`Retell error: ${result.message}`, refunded:need};\n  }\n\n  // Log debit\n  logCreditMove_(ts, need, 0);\n\n  // Sent index for archive run stamping\n  appendSentIndex_(finalPhones, runNumber);\n\n  // Stamp Last Call today + clear Next Call (ingest will set if neutral)\n  try {\n    setLastCallForPhones_(\u0027Outbound Leads\u0027, finalPhones);\n  } catch(e){\n    Logger.log(\u0027setLastCallForPhones_ warning: \u0027 + e);\n  }\n\n  // Bump Run (by row numbers first; fallback by phone)\n  try {\n    const nextStr \u003d String(Math.min(Number(runNumber||1) + 1, 9)); // \"2\",\"3\",…\n    const rowNums \u003d finalRowsUsed.map(x \u003d\u003e x.rowNumber);\n    const wroteByRow \u003d setRunsByRowNumbers_(\u0027Outbound Leads\u0027, rowNums, nextStr);\n    const wroteByPhone \u003d wroteByRow ? 0 : setRunsForPhones_(\u0027Outbound Leads\u0027, finalPhones, nextStr);\n    Logger.log(`Run bump: rows\u003d${wroteByRow ? rowNums.length : 0}, phones\u003d${wroteByPhone}, next\u003d${nextStr}`);\n  } catch(e){\n    Logger.log(\u0027Run bump error: \u0027 + e);\n  }\n\n  return {ok:true, sent:need, balance_after:getBalance_()};\n}\n\n/** Set Run for specific 1-based row numbers on a tab. Returns true if any write occurred. */\nfunction setRunsByRowNumbers_(tabName, rowNumbers, valueToWrite){\n  if (!rowNumbers || !rowNumbers.length) return false;\n  const ss \u003d ssById_(CFG().OUTBOUND_SS_ID);\n  const sh \u003d sh_(ss, tabName);\n  const {headers} \u003d getSheetData_(sh);\n  if (!headers.length) return false;\n  const H \u003d headerMap_(headers);\n  const rCol \u003d H[\u0027run\u0027];\n  if (rCol \u003d\u003d null) { Logger.log(\u0027setRunsByRowNumbers_: missing Run column\u0027); return false; }\n\n  // unique, valid, sorted\n  const rows \u003d Array.from(new Set(rowNumbers)).filter(n \u003d\u003e n \u0026\u0026 n\u003e\u003d2).sort((a,b)\u003d\u003ea-b);\n  if (!rows.length) return false;\n\n  let wrote \u003d false;\n  let i \u003d 0;\n  while (i \u003c rows.length){\n    const start \u003d rows[i];\n    let end \u003d start, j \u003d i+1;\n    while (j \u003c rows.length \u0026\u0026 rows[j] \u003d\u003d\u003d end+1) { end \u003d rows[j]; j++; }\n    const len \u003d end - start + 1;\n    sh.getRange(start, rCol+1, len, 1).setValues(Array(len).fill([valueToWrite]));\n    wrote \u003d true;\n    i \u003d j;\n  }\n  return wrote;\n}\n\n/** Fallback: set Run for a list of phones on a given tab. Returns rows written count. */\nfunction setRunsForPhones_(tabName, phoneList, valueToWrite){\n  if (!phoneList || !phoneList.length) return 0;\n  const ss \u003d ssById_(CFG().OUTBOUND_SS_ID);\n  const sh \u003d sh_(ss, tabName);\n  const {headers, rows} \u003d getSheetData_(sh);\n  if (!headers.length || !rows.length) return 0;\n\n  const H \u003d headerMap_(headers);\n  const pCol \u003d H[\u0027phone\u0027], rCol \u003d H[\u0027run\u0027];\n  if (pCol \u003d\u003d null || rCol \u003d\u003d null) { Logger.log(`setRunsForPhones_: missing Phone/Run on \"${tabName}\"`); return 0; }\n\n  // phone → row#\n  const indexByPhone \u003d {};\n  for (let i\u003d0;i\u003crows.length;i++){\n    const norm \u003d normalizePhone_(rows[i][pCol]);\n    if (norm) indexByPhone[norm] \u003d i+2;\n  }\n\n  const targets \u003d [];\n  phoneList.forEach(p\u003d\u003e{\n    const ri \u003d indexByPhone[normalizePhone_(p)];\n    if (ri) targets.push(ri);\n  });\n  if (!targets.length) return 0;\n\n  targets.sort((a,b)\u003d\u003ea-b);\n  let written \u003d 0, i\u003d0;\n  while (i\u003ctargets.length){\n    const start \u003d targets[i];\n    let end \u003d start, j\u003di+1;\n    while (j\u003ctargets.length \u0026\u0026 targets[j]\u003d\u003d\u003dend+1){ end\u003dtargets[j]; j++; }\n    const len \u003d end-start+1;\n    sh.getRange(start, rCol+1, len, 1).setValues(Array(len).fill([valueToWrite]));\n    written +\u003d len; i\u003dj;\n  }\n  return written;\n}\n\n/** Stamp “Last Call” (yyyy-MM-dd) and clear “Next Call” so ingest can set it if neutral later. */\nfunction setLastCallForPhones_(tabName, phoneList) {\n  if (!phoneList || !phoneList.length) return;\n  const ss \u003d ssById_(CFG().OUTBOUND_SS_ID);\n  const sh \u003d ss.getSheetByName(tabName);\n  if (!sh) return;\n\n  const {headers, rows} \u003d getSheetData_(sh);\n  const H \u003d headerMap_(headers);\n  const pCol \u003d H[\u0027phone\u0027], lcCol \u003d H[\u0027last call\u0027], ncCol \u003d H[\u0027next call\u0027];\n  if (pCol\u003d\u003dnull) { Logger.log(\u0027setLastCallForPhones_: missing Phone column\u0027); return; }\n\n  // Build phone → row#\n  const map \u003d {};\n  for (let i\u003d0;i\u003crows.length;i++){\n    const norm \u003d normalizePhone_(rows[i][pCol]);\n    if (norm) map[norm] \u003d i+2;\n  }\n  const ymd \u003d Utilities.formatDate(new Date(), CFG().CT_TZ, \u0027yyyy-MM-dd\u0027);\n\n  const targets \u003d [];\n  phoneList.forEach(ph\u003d\u003e{\n    const ri \u003d map[normalizePhone_(ph)];\n    if (ri) targets.push(ri);\n  });\n  if (!targets.length) return;\n\n  targets.sort((a,b)\u003d\u003ea-b);\n  let i\u003d0;\n  while (i\u003ctargets.length){\n    const start \u003d targets[i];\n    let end \u003d start, j\u003di+1;\n    while (j\u003ctargets.length \u0026\u0026 targets[j]\u003d\u003d\u003dend+1){ end\u003dtargets[j]; j++; }\n    const len \u003d end-start+1;\n\n    if (lcCol!\u003dnull) {\n      const rngLC \u003d sh.getRange(start, lcCol+1, len, 1);\n      rngLC.setNumberFormat(\u0027yyyy-mm-dd\u0027);\n      rngLC.setValues(Array(len).fill([ymd]));\n    }\n    if (ncCol!\u003dnull) {\n      const rngNC \u003d sh.getRange(start, ncCol+1, len, 1);\n      rngNC.setValue(\u0027\u0027); // clear; ingest will set if neutral outcome later\n    }\n    i\u003dj;\n  }\n}\n\nconst SCRIPT_PROPS \u003d PropertiesService.getScriptProperties();\nconst TRIGGER_FUNCTION_NAME \u003d \u0027processSendRunBatch\u0027;\n\n/**\n * Orchestrator function to start a long-running send process.\n * This function sets up the initial state and creates a trigger to start the work.\n * @param {string} sourceTab - The name of the sheet to read tasks from.\n * @param {number} runNumber - The current run number.\n * @param {number} limit - The total number of tasks to process.\n * @returns {Object} An object indicating that the process has started.\n */\nfunction startHubSendRun(sourceTab, runNumber, limit) {\n  const lock \u003d LockService.getScriptLock();\n  if (!lock.tryLock(5000)) {\n    return { ok: false, error: \u0027A run is already in progress. Please wait.\u0027 };\n  }\n\n  try {\n    // Clean up any old trigger and properties first\n    _deleteTrigger(TRIGGER_FUNCTION_NAME);\n    SCRIPT_PROPS.deleteProperty(\u0027sendRunState\u0027);\n\n    const { tasks, rowsUsed } \u003d collectTasksForRun_(sourceTab, runNumber);\n\n    if (!tasks.length) {\n      return { ok: false, error: `No eligible leads for Run ${runNumber}.` };\n    }\n\n    const balance \u003d getBalance_();\n    const perRequest \u003d (limit \u0026\u0026 isFinite(limit)) ? limit : CFG().MAX_PER_RUN;\n    const toSendCount \u003d Math.min(tasks.length, balance, perRequest, 1000); // hard cap 1,000\n\n    if (toSendCount \u003c\u003d 0) {\n      const reason \u003d (balance \u003c 1) ? \u0027Insufficient credits\u0027 : \u0027No tasks to send\u0027;\n      return { ok: false, error: `${reason}.` };\n    }\n\n    const state \u003d {\n      sourceTab: sourceTab,\n      runNumber: runNumber,\n      totalToSend: toSendCount,\n      tasks: tasks.slice(0, toSendCount),\n      rowsUsed: rowsUsed.slice(0, toSendCount),\n      processedCount: 0,\n      okCount: 0,\n      failCount: 0,\n      startTime: new Date().getTime(),\n      user: Session.getActiveUser().getEmail()\n    };\n\n    SCRIPT_PROPS.setProperty(\u0027sendRunState\u0027, JSON.stringify(state));\n\n    ScriptApp.newTrigger(TRIGGER_FUNCTION_NAME)\n      .timeBased()\n      .after(100) // 100 ms delay\n      .create();\n\n    const message \u003d `Started processing ${toSendCount} tasks for Run ${runNumber}.`;\n    return { ok: true, message: message };\n\n  } catch (e) {\n    return { ok: false, error: `Failed to start run: ${e.toString()}` };\n  } finally {\n    lock.releaseLock();\n  }\n}\n\n/**\n * Deletes a trigger by its handler function name.\n * @param {string} functionName - The name of the function the trigger calls.\n */\nfunction _deleteTrigger(functionName) {\n  try {\n    const triggers \u003d ScriptApp.getProjectTriggers();\n    for (const trigger of triggers) {\n      if (trigger.getHandlerFunction() \u003d\u003d\u003d functionName) {\n        ScriptApp.deleteTrigger(trigger);\n      }\n    }\n  } catch (e) {\n    // ignore errors\n  }\n}\n\n/**\n * The worker function that processes a batch of tasks.\n */\nfunction processSendRunBatch() {\n  const startTime \u003d Date.now();\n  const lock \u003d LockService.getScriptLock();\n  if (!lock.tryLock(15000)) {\n    return;\n  }\n\n  let state;\n  try {\n    const stateJson \u003d SCRIPT_PROPS.getProperty(\u0027sendRunState\u0027);\n    if (!stateJson) {\n      _deleteTrigger(TRIGGER_FUNCTION_NAME);\n      return;\n    }\n    state \u003d JSON.parse(stateJson);\n\n    const BATCH_SIZE_MAX \u003d 100; // Keep batches smaller\n    const timeRemaining \u003d (300 - (Date.now() - startTime) / 1000);\n    const dynamicBatchSize \u003d timeRemaining \u003c 30 ? 20 : (timeRemaining \u003c 60 ? 50 : BATCH_SIZE_MAX);\n\n    const remainingTasks \u003d state.tasks.slice(state.processedCount);\n    const batchTasks \u003d remainingTasks.slice(0, dynamicBatchSize);\n    const batchRowsUsed \u003d state.rowsUsed.slice(state.processedCount, state.processedCount + batchTasks.length);\n\n    if (batchTasks.length \u003d\u003d\u003d 0) {\n      _finalizeRun(state);\n      return;\n    }\n\n    const ts \u003d Utilities.formatDate(new Date(), CFG().CT_TZ, \u0027yyyy-MM-dd HH:mm:ss\u0027);\n    const bal \u003d getBalance_();\n    const need \u003d batchTasks.length;\n\n    // Debit credits for the batch\n    setBalance_(bal - need);\n\n    const result \u003d sendBatchToRetell_(state.runNumber, batchTasks);\n\n    if (!result.ok) {\n      // Refund and log failure for the whole batch\n      setBalance_(getBalance_() + need);\n      logCreditMove_(ts, 0, need);\n      state.failCount +\u003d need;\n    } else {\n      // Log success for the whole batch\n      logCreditMove_(ts, need, 0);\n      state.okCount +\u003d need;\n\n      const phonesSent \u003d batchRowsUsed.map(r \u003d\u003e r.phone);\n      const rowsSent \u003d batchRowsUsed.map(r \u003d\u003e r.rowNumber);\n\n      appendSentIndex_(phonesSent, state.runNumber);\n      setLastCallForPhones_(state.sourceTab, phonesSent);\n\n      const nextRun \u003d Math.min(state.runNumber + 1, 9);\n      setRunsByRowNumbers_(state.sourceTab, rowsSent, String(nextRun));\n    }\n\n    state.processedCount +\u003d batchTasks.length;\n    SCRIPT_PROPS.setProperty(\u0027sendRunState\u0027, JSON.stringify(state));\n\n    if (state.processedCount \u003e\u003d state.totalToSend) {\n      _finalizeRun(state);\n    } else {\n      _ensureTrigger(TRIGGER_FUNCTION_NAME, 1);\n    }\n\n  } catch (e) {\n    if(state) {\n      _finalizeRun(state, `Error: ${e.toString()}`);\n    } else {\n      _deleteTrigger(TRIGGER_FUNCTION_NAME);\n      SCRIPT_PROPS.deleteProperty(\u0027sendRunState\u0027);\n    }\n  } finally {\n    lock.releaseLock();\n  }\n}\n\n/**\n * Ensures a trigger for the given function exists.\n */\nfunction _ensureTrigger(functionName, minutes) {\n  _deleteTrigger(functionName);\n  ScriptApp.newTrigger(functionName)\n    .timeBased()\n    .after(minutes * 60 * 1000)\n    .create();\n}\n\n/**\n * Finalizes a run, cleaning up resources.\n */\nfunction _finalizeRun(state, errorMessage) {\n  _deleteTrigger(TRIGGER_FUNCTION_NAME);\n  SCRIPT_PROPS.deleteProperty(\u0027sendRunState\u0027);\n\n  // Mark cooldown only if at least one call was successful\n  if (state.okCount \u003e 0 \u0026\u0026 typeof markCooldownNow_ \u003d\u003d\u003d \u0027function\u0027) {\n    markCooldownNow_(\u0027GLOBAL\u0027);\n  }\n\n  // Final logging can be added here if needed\n}"},{"id":"30b4c22b-fe4a-4c3d-9cd8-7b9dff2a3d69","name":"Hub_Utils","type":"server_js","source":"\n// Hub_Utils.js - Centralized utility functions\n// This file must be loaded first as other files depend on these utilities\n\n/** Get spreadsheet by ID */\nfunction ssById_(id) { \n  return SpreadsheetApp.openById(id); \n}\n\n/** Get or create sheet by name */\nfunction sh_(ss, name) { \n  return ss.getSheetByName(name) || ss.insertSheet(name); \n}\n\n/** Ensure headers exist on sheet */\nfunction ensureHeaders_(sh, headers) {\n  const has \u003d sh.getLastRow() ? sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0] : [];\n  if (!has.length) { \n    sh.getRange(1, 1, 1, headers.length).setValues([headers]); \n    return; \n  }\n  // append missing columns\n  const missing \u003d headers.filter(h \u003d\u003e !has.includes(h));\n  if (missing.length) {\n    sh.insertColumnsAfter(has.length || 1, missing.length);\n    sh.getRange(1, has.length + 1, 1, missing.length).setValues([missing]);\n  }\n}\n\n/** Build header index map (lowercase keys) */\nfunction headerMap_(headers) {\n  const m \u003d {};\n  headers.forEach((h, i) \u003d\u003e {\n    const key \u003d String(h).trim().toLowerCase();\n    m[key] \u003d i;\n    // Also add version without spaces\n    m[key.replace(/\\s+/g, \u0027\u0027)] \u003d i;\n  });\n  return m;\n}\n\n/** Get sheet data as headers and rows */\nfunction getSheetData_(sh) {\n  const lastR \u003d sh.getLastRow(), lastC \u003d sh.getLastColumn();\n  if (lastR \u003c 2 || lastC \u003c 1) return { headers: [], rows: [] };\n  const vals \u003d sh.getRange(1, 1, lastR, lastC).getValues();\n  const headers \u003d vals.shift();\n  return { headers, rows: vals };\n}\n\n/** Get current time in Central Time */\nfunction nowCT_() { \n  return new Date(Utilities.formatDate(new Date(), CFG().CT_TZ, \"yyyy-MM-dd\u0027T\u0027HH:mm:ss\")); \n}\n\n/** Check if within call window */\nfunction withinCallWindow_() {\n  const now \u003d new Date();\n  const CT_TZ \u003d CFG().CT_TZ || \u0027America/Chicago\u0027;\n  const hour \u003d Number(Utilities.formatDate(now, CT_TZ, \u0027H\u0027)); // 0..23\n  const CALL_START_HOUR_CT \u003d 7;   // 7 AM CT\n  const CALL_END_HOUR_CT \u003d 20;    // 8 PM CT\n  return (hour \u003e\u003d CALL_START_HOUR_CT \u0026\u0026 hour \u003c CALL_END_HOUR_CT);\n}\n\n/** Minutes until call window opens */\nfunction minutesUntilOpen_() {\n  const CT_TZ \u003d CFG().CT_TZ || \u0027America/Chicago\u0027;\n  const CALL_START_HOUR_CT \u003d 7;\n  const now \u003d new Date();\n  const tzNowStr \u003d Utilities.formatDate(now, CT_TZ, \"yyyy-MM-dd\u0027T\u0027HH:mm:ss\");\n  const base \u003d new Date(tzNowStr);\n  const hour \u003d Number(Utilities.formatDate(base, CT_TZ, \u0027H\u0027));\n\n  if (hour \u003c CALL_START_HOUR_CT) {\n    const open \u003d new Date(base);\n    open.setHours(CALL_START_HOUR_CT, 0, 0, 0);\n    return Math.max(0, Math.ceil((open.getTime() - base.getTime()) / 60000));\n  }\n  // past END → until tomorrow START\n  const openTomorrow \u003d new Date(base);\n  openTomorrow.setDate(openTomorrow.getDate() + 1);\n  openTomorrow.setHours(CALL_START_HOUR_CT, 0, 0, 0);\n  return Math.max(0, Math.ceil((openTomorrow.getTime() - base.getTime()) / 60000));\n}\n\n/** Force every non-null property value to a string */\nfunction coerceToStringMap_(obj) {\n  const out \u003d {};\n  if (!obj || typeof obj !\u003d\u003d \u0027object\u0027) return out;\n  Object.keys(obj).forEach(k \u003d\u003e {\n    const v \u003d obj[k];\n    if (v !\u003d\u003d null \u0026\u0026 v !\u003d\u003d undefined) out[k] \u003d String(v);\n  });\n  return out;\n}\n\n/** Normalize phone to US E.164 (+1XXXXXXXXXX) */\nfunction normalizePhoneE164_(raw) {\n  let s \u003d String(raw || \u0027\u0027).trim();\n  // Handle weird \"\u003d+1...\" / \"\u003d1408...\" Sheet cases\n  if (s.startsWith(\u0027\u003d+\u0027)) s \u003d \u0027+\u0027 + s.slice(2);\n  else if (s.startsWith(\u0027\u003d\u0027)) s \u003d s.slice(1);\n  const digits \u003d s.replace(/\\D/g, \u0027\u0027); // keep only numbers\n  if (!digits) return \u0027\u0027;\n  if (digits.length \u003d\u003d\u003d 10) return \u0027+1\u0027 + digits;                 // US 10-digit\n  if (digits.length \u003d\u003d\u003d 11 \u0026\u0026 digits[0] \u003d\u003d\u003d \u00271\u0027) return \u0027+\u0027 + digits; // 1XXXXXXXXXX\n  if (digits.length \u003e\u003d 11 \u0026\u0026 digits.length \u003c\u003d 15) return \u0027+\u0027 + digits; // allow intl\n  return \u0027\u0027; // invalid\n}\n\n/** Normalize phone to 10-digit string (no country code) */\nfunction normalizePhone_(raw) {\n  if (!raw) return \u0027\u0027;\n  let s \u003d String(raw).trim();\n  // Handle Excel formula artifacts\n  if (s.startsWith(\u0027\u003d+\u0027)) s \u003d \u0027+\u0027 + s.slice(2);\n  else if (s.startsWith(\u0027\u003d\u0027)) s \u003d s.slice(1);\n  // Extract digits only\n  const d \u003d s.replace(/\\D/g, \u0027\u0027);\n  if (!d) return \u0027\u0027;\n  // Handle US numbers\n  if (d.length \u003d\u003d\u003d 11 \u0026\u0026 d[0] \u003d\u003d\u003d \u00271\u0027) return d.slice(1);\n  if (d.length \u003d\u003d\u003d 10) return d;\n  if (d.length \u003e 10) return d.slice(-10);\n  return \u0027\u0027;\n}\n\n/** Clean up orphaned triggers */\nfunction cleanupOrphanedTriggers() {\n  const triggers \u003d ScriptApp.getProjectTriggers();\n  const P \u003d PropertiesService.getScriptProperties();\n  const validTriggerId \u003d P.getProperty(\u0027WEBHOOK_POLL_TRIGGER_ID\u0027);\n  const sendTriggerId \u003d P.getProperty(\u0027SEND_RUN_TRIGGER_ID\u0027);\n  \n  triggers.forEach(trigger \u003d\u003e {\n    const func \u003d trigger.getHandlerFunction();\n    const id \u003d trigger.getUniqueId();\n    \n    // Clean up webhook polling triggers\n    if (func \u003d\u003d\u003d \u0027hubIngestWebhooks_\u0027 \u0026\u0026 id !\u003d\u003d validTriggerId) {\n      ScriptApp.deleteTrigger(trigger);\n      console.log(`Cleaned up orphaned webhook trigger: ${id}`);\n    }\n    \n    // Clean up send run triggers\n    if (func \u003d\u003d\u003d \u0027processSendRunBatch\u0027 \u0026\u0026 id !\u003d\u003d sendTriggerId) {\n      ScriptApp.deleteTrigger(trigger);\n      console.log(`Cleaned up orphaned send trigger: ${id}`);\n    }\n  });\n}\n\n/** Thread-safe credit balance update */\nfunction updateCreditBalance_(delta) {\n  const lock \u003d LockService.getScriptLock();\n  try {\n    lock.waitLock(10000);\n    const current \u003d getBalance_();\n    const newBalance \u003d current + delta;\n    setBalance_(newBalance);\n    return newBalance;\n  } catch (e) {\n    throw new Error(`Failed to update credit balance: ${e.toString()}`);\n  } finally {\n    lock.releaseLock();\n  }\n}"},{"id":"3a458908-7c0e-4708-9b24-24d426961e7d","name":"test","type":"server_js","source":"function testHubEndpoint() {\n  // 1. PASTE the Web App URL from your Hub deployment here\n  const HUB_URL \u003d \"https://script.google.com/macros/s/AKfycbzq5Y4uaIWHVm_VVTy1H8uySi9zs6ZZfXfoDe4vdBSPy_wCGBgubc4Oba_-ylWjbzB0Jw/exec\"; \n  \n  // 2. PASTE your Client Token from the Hub\u0027s script properties here\n  const CLIENT_TOKEN \u003d \"tok_9mxqxyei19cszn03yocqbf\";\n\n  const payload \u003d {\n    token: CLIENT_TOKEN,\n    action: \u0027balance\u0027 // Using a simple POST action for this test\n  };\n\n  const options \u003d {\n    method: \u0027post\u0027,\n    contentType: \u0027application/json\u0027,\n    payload: JSON.stringify(payload),\n    muteHttpExceptions: true\n  };\n\n  console.log(\"--- Starting Independent Hub Test ---\");\n  console.log(`Calling URL: ${HUB_URL}`);\n  \n  const response \u003d UrlFetchApp.fetch(HUB_URL, options);\n  const responseCode \u003d response.getResponseCode();\n  const responseText \u003d response.getContentText();\n\n  console.log(\"--- Test Results ---\");\n  console.log(`HTTP Status Code: ${responseCode}`); // This is the critical line\n  console.log(`Response Text: ${responseText}`);\n  console.log(\"--------------------\");\n}\n\nfunction testStartHubSendRun() {\n  console.log(\"--- Starting test for startHubSendRun ---\");\n\n  // Mock dependencies\n  const sourceTab \u003d \u0027Outbound Leads\u0027;\n  const runNumber \u003d 1;\n  const limit \u003d 10;\n\n  // Call the function\n  const result \u003d startHubSendRun(sourceTab, runNumber, limit);\n  console.log(`Result from startHubSendRun: ${JSON.stringify(result)}`);\n\n  if (!result.ok) {\n    if (result.error \u003d\u003d\u003d \u0027Insufficient credits or no tasks to send.\u0027) {\n      console.warn(\"Test could not run due to insufficient credits or no tasks. This is not a failure of the new logic.\");\n      return;\n    }\n    console.error(\"Test failed: startHubSendRun did not return ok:true.\");\n    return;\n  }\n\n  // Check properties\n  const state \u003d PropertiesService.getScriptProperties().getProperty(\u0027sendRunState\u0027);\n  if (!state) {\n    console.error(\"Test failed: sendRunState was not created in PropertiesService.\");\n  } else {\n    console.log(\"Test passed: sendRunState was created.\");\n  }\n\n  // Check trigger\n  const triggers \u003d ScriptApp.getProjectTriggers();\n  const triggerExists \u003d triggers.some(t \u003d\u003e t.getHandlerFunction() \u003d\u003d\u003d \u0027processSendRunBatch\u0027);\n  if (!triggerExists) {\n    console.error(\"Test failed: Trigger for processSendRunBatch was not created.\");\n  } else {\n    console.log(\"Test passed: Trigger was created.\");\n  }\n\n  // Cleanup\n  console.log(\"--- Cleaning up test artifacts ---\");\n  _deleteTrigger(\u0027processSendRunBatch\u0027);\n  PropertiesService.getScriptProperties().deleteProperty(\u0027sendRunState\u0027);\n  console.log(\"Cleanup complete.\");\n}"}]}