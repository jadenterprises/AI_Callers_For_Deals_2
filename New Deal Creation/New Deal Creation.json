{"files":[{"id":"b0ebcfc3-2aa3-42a4-937d-572a567a3753","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"America/Chicago\",\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"runtimeVersion\": \"V8\",\n  \"oauthScopes\": [\n    \"https://www.googleapis.com/auth/drive\",\n    \"https://www.googleapis.com/auth/spreadsheets\",\n    \"https://www.googleapis.com/auth/script.external_request\",\n    \"https://www.googleapis.com/auth/script.projects\",\n    \"https://www.googleapis.com/auth/script.deployments\",\n    \"https://www.googleapis.com/auth/cloud-platform\",\n    \"https://www.googleapis.com/auth/script.scriptapp\"\n  ],\n  \"webapp\": {\n    \"executeAs\": \"USER_DEPLOYING\",\n    \"access\": \"ANYONE_ANONYMOUS\"\n  }\n}"},{"id":"0286d788-65e1-460e-b69b-bcd0b2f41c9c","name":"Code","type":"server_js","source":"/**** Client Factory — two‑step provisioning (async finalize, bound‑script auto‑select, mini status) ****/\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 0) Defaults \u0026 Setup \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n\r\nconst CREDIT_LEDGER_SS_ID \u003d \u00271C6WQsWzfopG-gJzozbGV33Y6SlZ1PhV76DgNjqHrF0c\u0027;\r\nconst DEFAULT_BUCKET_WRITER \u003d \u0027retell-functions-runner@retell-calling.iam.gserviceaccount.com\u0027;\r\n\r\n// MODIFIED: Increased timeouts to give Google\u0027s infrastructure more time to propagate changes.\r\nconst SCRIPT_VISIBILITY_TIMEOUT_MS \u003d 300000;  // 5m (was 3m)\r\nconst DEFAULT_FINALIZE_DELAY_MIN   \u003d 15;      // 15m (was 4m)\r\n\r\n// Keys to verify\r\nconst HUB_VERIFY_KEYS      \u003d [\u0027CLIENT_TOKEN\u0027,\u0027ADMIN_TOKEN\u0027,\u0027OUTBOUND_SS_ID\u0027];\r\nconst PORTAL_VERIFY_KEYS   \u003d [\u0027CLIENT_TOKEN\u0027,\u0027OUTBOUND_SS_ID\u0027,\u0027HUB_URL\u0027];\r\nconst OUTBOUND_VERIFY_KEYS \u003d [\u0027RESULTS_SS_ID\u0027,\u0027HUB_URL\u0027,\u0027CLIENT_TOKEN\u0027]; // Removed OUTBOUND_SS_ID as it\u0027s redundant for the script bound to it\r\nconst RESULTS_VERIFY_KEYS  \u003d [\u0027HUB_URL\u0027,\u0027CLIENT_TOKEN\u0027];\r\n\r\nfunction FACTORY_DEFAULTS() {\r\n  const P \u003d PropertiesService.getScriptProperties();\r\n  const v \u003d k \u003d\u003e (P.getProperty(k) || \u0027\u0027).trim();\r\n  return {\r\n    CLIENTS_PARENT_FOLDER_ID: \u00271eVQK1ZNZK7Qu7WKXtaxrnNlqLP1g6V7v\u0027,\r\n    ADMIN_PARENT_FOLDER_ID:   \u002715J-gPX-xecM6cbWtcl0lzTr0-puwChAy\u0027,\r\n    GCP_PROJECT_ID:           \u0027retell-calling\u0027,\r\n    TPL_HUB_SCRIPT_ID:    v(\u0027TPL_HUB_SCRIPT_ID\u0027)    || \u00271LQRaVKmIFehvU_adXncThZGFYWo5YeYS-u-sNOh1qdgW5lh8LD2gk6N1\u0027,\r\n    TPL_PORTAL_SCRIPT_ID: v(\u0027TPL_PORTAL_SCRIPT_ID\u0027) || \u002718wcdsRNLMgnlfdNISaamQSdn2aR2injY8PfULab_LAST1xa8ZEiwpn8Y\u0027,\r\n    TPL_OUTBOUND_SS_ID:   v(\u0027TPL_OUTBOUND_SS_ID\u0027)   || \u00271Qr6CISTQec_K5MpGxzccgdPx9B8UctvHTzr-8c-k3tY\u0027,\r\n    TPL_RESULTS_SS_ID:    v(\u0027TPL_RESULTS_SS_ID\u0027)    || \u00271_rAhfg04DRlAmS7fahCpid1qqFB7iqxAOOyf5V-kxso\u0027,\r\n    BUCKET_LOCATION: v(\u0027BUCKET_LOCATION\u0027) || \u0027us-south1\u0027,\r\n    BUCKET_NAME_PREFIX: v(\u0027BUCKET_NAME_PREFIX\u0027) || \u0027retell\u0027,\r\n    RETELL_URL:       v(\u0027RETELL_URL\u0027) || \u0027https://api.retellai.com/create-batch-call\u0027,\r\n    CT_TZ:            v(\u0027CT_TZ\u0027) || \u0027America/Chicago\u0027,\r\n    DEFAULT_RUN_LIMIT: Number(v(\u0027DEFAULT_RUN_LIMIT\u0027) || 1000),\r\n  };\r\n}\r\n\r\nfunction canonicalRetellBatchUrl_(rawUrl) {\r\n  const CANON \u003d \u0027https://api.retellai.com/create-batch-call\u0027;\r\n  const trimmed \u003d (rawUrl \u003d\u003d null) ? \u0027\u0027 : String(rawUrl).trim();\r\n  if (!trimmed) {\r\n    return { url: CANON, normalized: true, previous: \u0027\u0027, reason: \u0027missing\u0027 };\r\n  }\r\n  const withoutTrailing \u003d trimmed.replace(/\\/+$/, \u0027\u0027);\r\n  if (withoutTrailing \u003d\u003d\u003d CANON) {\r\n    return { url: CANON, normalized: false, previous: trimmed, reason: \u0027\u0027 };\r\n  }\r\n  // If it\u0027s the old URL or some other variation, normalize it.\r\n  return { url: CANON, normalized: true, previous: trimmed, reason: \u0027legacy\u0027 };\r\n}\r\n\r\nfunction assertAppsScriptApiUserEnabled_() {\r\n  const r \u003d UrlFetchApp.fetch(\r\n    `https://script.googleapis.com/v1/projects/${ScriptApp.getScriptId()}/content`,\r\n    { headers: { Authorization: \u0027Bearer \u0027 + ScriptApp.getOAuthToken() }, muteHttpExceptions: true }\r\n  );\r\n  if (r.getResponseCode() \u003d\u003d\u003d 403 \u0026\u0026\r\n      /User has not enabled the Apps Script API/i.test(r.getContentText())) {\r\n    throw new Error(\u0027Turn on “Google Apps Script API” at https://script.google.com/home/usersettings then retry.\u0027);\r\n  }\r\n  if (r.getResponseCode() \u003e\u003d 300) throw new Error(\u0027Apps Script API probe failed: \u0027 + r.getContentText());\r\n}\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 1) STEP 1 — CREATE \u0026 GET URLS \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 1a) NEW: Start Provisioning (Step 1 via UI) \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n\r\nfunction startProvisioning(opts) {\r\n  // This is the new entry point, called from the UI.\r\n  // It performs the initial, fast setup steps and then starts the async state machine.\r\n  assertAppsScriptApiUserEnabled_();\r\n  const F \u003d FACTORY_DEFAULTS();\r\n  const missing \u003d [];\r\n  [\u0027CLIENTS_PARENT_FOLDER_ID\u0027,\u0027ADMIN_PARENT_FOLDER_ID\u0027,\u0027GCP_PROJECT_ID\u0027,\r\n   \u0027TPL_HUB_SCRIPT_ID\u0027,\u0027TPL_PORTAL_SCRIPT_ID\u0027,\u0027TPL_OUTBOUND_SS_ID\u0027,\u0027TPL_RESULTS_SS_ID\u0027\r\n  ].forEach(k \u003d\u003e { if (!F[k]) missing.push(k); });\r\n  if (missing.length) throw new Error(\u0027Missing defaults: \u0027 + missing.join(\u0027, \u0027));\r\n\r\n  const clientName    \u003d String(opts.clientName || \u0027\u0027).trim();\r\n  if (!clientName) throw new Error(\u0027clientName is required.\u0027);\r\n\r\n  // --- Start of original provisionOnly logic ---\r\n  const slug          \u003d (String(opts.slug || clientName).toLowerCase().replace(/[^a-z0-9]+/g,\u0027-\u0027)).replace(/(^-+|-+$)/g,\u0027\u0027);\r\n  const shareWith     \u003d [].concat(opts.shareWith || []);\r\n\r\n  // Folders\r\n  const clientsRoot \u003d DriveApp.getFolderById(F.CLIENTS_PARENT_FOLDER_ID);\r\n  const adminRoot   \u003d DriveApp.getFolderById(F.ADMIN_PARENT_FOLDER_ID);\r\n  const clientRoot  \u003d clientsRoot.createFolder(`${clientName}`);\r\n  const archiveFolder \u003d clientRoot.createFolder(\u0027Archive\u0027);\r\n  const adminClientRoot \u003d adminRoot.createFolder(`${clientName} - Admin`);\r\n  try { if (shareWith.length) shareWith.forEach(e \u003d\u003e { if (e) clientRoot.addEditor(e); }); } catch (_) {}\r\n\r\n  // --- End of initial setup ---\r\n\r\n  // Create the initial record object.\r\n  // We store the original options to use them in subsequent steps.\r\n  const record \u003d {\r\n    _originalOpts: opts, // Store original options for later steps\r\n    client: { name: clientName, slug },\r\n    timestamps: { created: new Date().toISOString() },\r\n    drive: {\r\n      clientFolderId: clientRoot.getId(),\r\n      adminFolderId:  adminClientRoot.getId(),\r\n      archiveFolderId: archiveFolder.getId(),\r\n    },\r\n    sheets:  {},\r\n    scripts: {},\r\n    gcs:     {},\r\n    props:   {},\r\n    provisioningStatus: \u0027CREATE_SHEETS\u0027 // This is the first state for the machine\r\n  };\r\n\r\n  // Save the initial record to get a file ID.\r\n  const recordId \u003d saveProvisionRecord_(adminClientRoot.getId(), record);\r\n\r\n  // Now that we have an ID, stamp it onto the record itself for future reference.\r\n  record.recordFileId \u003d recordId;\r\n  updateProvisionRecord_(recordId, record);\r\n\r\n  // Kick off the state machine.\r\n  _scheduleNextStep_(recordId, \u0027CREATE_SHEETS\u0027);\r\n\r\n  // Return to the UI immediately.\r\n  return {\r\n    ok: true,\r\n    recordFileId: recordId,\r\n    message: `Provisioning started for ${clientName}. Process is running in the background.`,\r\n  };\r\n}\r\n\r\nfunction editorUrl_(scriptId){ return `https://script.google.com/home/projects/${encodeURIComponent(scriptId)}/edit`; }\r\n// NEW: Helper for Sheet URLs\r\nfunction sheetUrl_(ssId){ return `https://docs.google.com/spreadsheets/d/${encodeURIComponent(ssId)}/edit`; }\r\n\r\n\r\nfunction buildFinalizeUrl_(base, props) {\r\n  if (!base) return \u0027\u0027;\r\n  const json \u003d JSON.stringify(props || {});\r\n  const b64  \u003d Utilities.base64EncodeWebSafe(json);\r\n  const join \u003d base.indexOf(\u0027?\u0027) \u003e -1 ? \u0027\u0026\u0027 : \u0027?\u0027;\r\n  return `${base}${join}apply\u003d${b64}`;\r\n}\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 2) STEP 2 — FINALIZE \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n\r\n// (finalizeProvisionFromRecord, getFinalizeSummary_, setPropsThenVerify_, _verifyPropsWebOrExec_ remain the same)\r\n\r\nfunction finalizeProvisionFromRecord(recordFileId){\r\n  if (!recordFileId) throw new Error(\u0027recordFileId required.\u0027);\r\n  const rec \u003d readProvisionRecord_(recordFileId);\r\n\r\n  // RE‑TARGET bound scripts to the “best” (Copied) project and make sure they’re deployed\r\n  retargetAndDeployBoundScripts_(rec);        // updates rec + record file if it changes\r\n\r\n  // Hub + Portal\r\n  setPropsThenVerify_(rec.scripts.hubScriptId,    rec.props.hubProps,\r\n                       [rec.scripts.hubExecUrl, rec.scripts.hubExecUrl \u0026\u0026 rec.scripts.hubExecUrl.replace(\u0027/exec\u0027,\u0027/dev\u0027)],\r\n                       HUB_VERIFY_KEYS);\r\n  setPropsThenVerify_(rec.scripts.portalScriptId, rec.props.portalProps,\r\n                       [rec.scripts.portalExecUrl, rec.scripts.portalExecUrl \u0026\u0026 rec.scripts.portalExecUrl.replace(\u0027/exec\u0027,\u0027/dev\u0027)],\r\n                       PORTAL_VERIFY_KEYS);\r\n\r\n  // Outbound \u0026 Results (BOUND) — correct targets\r\n  // This is now mostly redundant if the manual loader is used, but serves as a backup.\r\n  setPropsThenVerify_(rec.scripts.outboundScriptId, rec.props.outboundProps,\r\n                       [rec.scripts.outboundExecUrl, rec.scripts.outboundDevUrl],\r\n                       OUTBOUND_VERIFY_KEYS);\r\n  setPropsThenVerify_(rec.scripts.resultsScriptId,  rec.props.resultsProps,\r\n                       [rec.scripts.resultsExecUrl,  rec.scripts.resultsDevUrl],\r\n                       RESULTS_VERIFY_KEYS);\r\n\r\n  return getFinalizeSummary_(rec);\r\n}\r\n\r\nfunction getFinalizeSummary_(rec){\r\n  const hubDev    \u003d (rec.scripts.hubExecUrl||\u0027\u0027).replace(/\\/exec(\\?.*)?$/,\u0027/dev\u0027);\r\n  const portalDev \u003d (rec.scripts.portalExecUrl||\u0027\u0027).replace(/\\/exec(\\?.*)?$/,\u0027/dev\u0027);\r\n  return {\r\n    ok: true,\r\n    recordFileId: rec.recordFileId || \u0027\u0027,\r\n    manualFinalize: {\r\n      hubFinalizeDevUrl:      buildFinalizeUrl_(hubDev,                                   rec.props.hubProps),\r\n      portalFinalizeDevUrl:   buildFinalizeUrl_(portalDev,                                rec.props.portalProps),\r\n      outboundFinalizeDevUrl: buildFinalizeUrl_(rec.scripts.outboundDevUrl,    rec.props.outboundProps),\r\n      resultsFinalizeDevUrl:  buildFinalizeUrl_(rec.scripts.resultsDevUrl,     rec.props.resultsProps),\r\n      hubEditorUrl:       editorUrl_(rec.scripts.hubScriptId),\r\n      portalEditorUrl:    editorUrl_(rec.scripts.portalScriptId),\r\n      outboundEditorUrl:  editorUrl_(rec.scripts.outboundScriptId),\r\n      resultsEditorUrl:   editorUrl_(rec.scripts.resultsScriptId),\r\n      note: \u0027If any still show “Missing”, open these /dev links once while logged in as the deployer.\u0027\r\n    }\r\n  };\r\n}\r\n\r\n// Web-app first, then Exec API fallback\r\nfunction setPropsThenVerify_(scriptId, props, urlCandidates, verifyKeys) {\r\n  verifyKeys \u003d verifyKeys || Object.keys(props||{});\r\n\r\n  if (!scriptId) {\r\n    Logger.log(\u0027Skipping setPropsThenVerify_ because scriptId is null (bound script likely not ready).\u0027);\r\n    return false;\r\n  }\r\n\r\n  // Optimization: Check if already set correctly\r\n  if (_verifyPropsWebOrExec_(scriptId, verifyKeys, urlCandidates)) {\r\n    Logger.log(`Skipping setPropsThenVerify_ for ${scriptId} as properties are already verified.`);\r\n    return true;\r\n  }\r\n\r\n  const MAX_WEB_RETRIES \u003d 3, SLEEP \u003d 5000;\r\n  for (let i \u003d 1; i \u003c\u003d MAX_WEB_RETRIES; i++) {\r\n    for (const u of (urlCandidates||[])) {\r\n      if (!u) continue;\r\n      const res \u003d _setPropsViaWebApp_(u, props);\r\n      Logger.log(`Attempt ${i}.0: web bootstrap (${u.indexOf(\u0027/dev\u0027)\u003e-1?\u0027/dev\u0027:\u0027/exec\u0027}) OK? ${res.ok} → ${u}`);\r\n      if (res.ok) {\r\n        if (_verifyPropsWebOrExec_(scriptId, verifyKeys, urlCandidates)) return true;\r\n      } else if (res.reason \u003d\u003d\u003d \u0027auth\u0027) {\r\n        Logger.log(`[Authorization Required] Could not set properties for script ${scriptId}. Please open the authorization URL and grant permissions.`);\r\n      }\r\n    }\r\n    Utilities.sleep(SLEEP);\r\n  }\r\n\r\n  try {\r\n    Logger.log(`Web bootstrap failed. Falling back to Execution API for ${scriptId}.`);\r\n    _safeSetScriptProps_(scriptId, props, \u0027script\u0027);\r\n    if (_verifyPropsWebOrExec_(scriptId, verifyKeys, urlCandidates)) return true;\r\n  } catch (e) {\r\n    Logger.log(`Execution API setProps failed for ${scriptId}: ${e}`);\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction _verifyPropsWebOrExec_(scriptId, keys, urlCandidates) {\r\n  try {\r\n    // Check if the project exists before attempting access\r\n    waitUntilProjectExists_(scriptId, 5000); // Shorter timeout for verification check\r\n    // Ensure bootstrap file exists for Exec API check\r\n    _ensureBootstrapFile_(scriptId);\r\n    // Create a version to ensure latest code is used by Exec API\r\n    _createVersionIfPossible_(scriptId, \u0027verify-props\u0027);\r\n    const got \u003d gas_scriptsRun_(scriptId, \u0027__bootstrapGetProps\u0027, [keys||[]]) || {};\r\n    if (got \u0026\u0026 typeof got \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 (keys||[]).every(k \u003d\u003e String(got[k]||\u0027\u0027) !\u003d\u003d \u0027\u0027)) return true;\r\n  } catch (e) {\r\n    // Log errors during verification but continue to web check\r\n    Logger.log(`Exec API verification failed for ${scriptId}: ${e}`);\r\n  }\r\n\r\n  for (const u of (urlCandidates||[])) {\r\n    const s \u003d _pingWebAppStatus_(u, keys);\r\n    if (s \u0026\u0026 s.hasProps \u0026\u0026 (keys||[]).every(k \u003d\u003e !!s.hasProps[k])) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 2a) Async Finalize \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// (scheduleFinalize_, cancelExistingFinalizeTriggers_, finalizeScheduled_ remain the same)\r\nfunction scheduleFinalize_(recordFileId, delayMinutes) {\r\n  const P \u003d PropertiesService.getScriptProperties();\r\n  P.setProperty(\u0027PENDING_FINALIZE_RECORD_ID\u0027, recordFileId);\r\n  try { cancelExistingFinalizeTriggers_(); } catch (e) { Logger.log(\u0027cancelExistingFinalizeTriggers_ ignored: \u0027+e); }\r\n  const when \u003d new Date(Date.now() + (Math.max(1, delayMinutes || DEFAULT_FINALIZE_DELAY_MIN))*60*1000);\r\n  try {\r\n    const trig \u003d ScriptApp.newTrigger(\u0027finalizeScheduled_\u0027).timeBased().at(when).create();\r\n    return { runAtIso: when.toISOString(), minutesFromNow: Math.round((when - new Date())/60000), triggerId: (trig.getUniqueId ? trig.getUniqueId() : \u0027\u0027) };\r\n  } catch (e) {\r\n    Logger.log(\u0027Trigger create failed: \u0027 + e);\r\n    return { runAtIso: when.toISOString(), minutesFromNow: Math.round((when - new Date())/60000), triggerId: \u0027\u0027, note: \u0027If needed, click Finalize NOW.\u0027 };\r\n  }\r\n}\r\nfunction cancelExistingFinalizeTriggers_() {\r\n  const trigs \u003d ScriptApp.getProjectTriggers();\r\n  (trigs || []).filter(t \u003d\u003e t.getHandlerFunction \u0026\u0026 t.getHandlerFunction() \u003d\u003d\u003d \u0027finalizeScheduled_\u0027)\r\n               .forEach(t \u003d\u003e { try { ScriptApp.deleteTrigger(t); } catch(_){} });\r\n}\r\nfunction finalizeScheduled_() {\r\n  const P \u003d PropertiesService.getScriptProperties();\r\n  const id \u003d P.getProperty(\u0027PENDING_FINALIZE_RECORD_ID\u0027);\r\n  if (!id) return;\r\n  try { finalizeProvisionFromRecord(id); }\r\n  catch (e){ Logger.log(\u0027finalizeScheduled_ error: \u0027 + e); }\r\n  finally { P.deleteProperty(\u0027PENDING_FINALIZE_RECORD_ID\u0027); try { cancelExistingFinalizeTriggers_(); } catch(_) {} }\r\n}\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 3) Admin menu (optional) \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// (onOpen, runFinalizeMostRecent, etc., remain the same)\r\nfunction onOpen() {\r\n  SpreadsheetApp.getUi().createMenu(\u0027Admin\u0027)\r\n    .addItem(\u0027Finalize — Most recent\u0027, \u0027runFinalizeMostRecent\u0027)\r\n    .addItem(\u0027Finalize — By name…\u0027, \u0027runFinalizeByName\u0027)\r\n    .addItem(\u0027Finalize — By record id…\u0027, \u0027runFinalizeByRecord\u0027)\r\n    .addSeparator()\r\n    .addItem(\u0027Show auth URLs (most recent)\u0027, \u0027runShowAuthUrls\u0027)\r\n    .addItem(\u0027List provision records\u0027, \u0027runListProvisionRecords\u0027)\r\n    .addToUi();\r\n}\r\nfunction runFinalizeMostRecent(){ Logger.log(JSON.stringify(finalizeMostRecent(), null, 2)); }\r\nfunction runFinalizeByName(){\r\n  const ui \u003d SpreadsheetApp.getUi();\r\n  const res \u003d ui.prompt(\u0027Finalize by Client Name\u0027, \u0027Enter the client name exactly:\u0027, ui.ButtonSet.OK_CANCEL);\r\n  if (res.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\r\n  Logger.log(JSON.stringify(finalizeProvisionByName(res.getResponseText()), null, 2));\r\n}\r\nfunction runFinalizeByRecord(){\r\n  const ui \u003d SpreadsheetApp.getUi();\r\n  const res \u003d ui.prompt(\u0027Finalize by Record ID\u0027, \u0027Paste the record file id:\u0027, ui.ButtonSet.OK_CANCEL);\r\n  if (res.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\r\n  Logger.log(JSON.stringify(finalizeProvisionFromRecord(res.getResponseText()), null, 2));\r\n}\r\nfunction runShowAuthUrls(){ Logger.log(JSON.stringify(showAuthUrlsForMostRecent(), null, 2)); }\r\nfunction runListProvisionRecords(){ Logger.log(JSON.stringify(listProvisionRecords(), null, 2)); }\r\n\r\nfunction listProvisionRecords(){\r\n  const F \u003d FACTORY_DEFAULTS();\r\n  const qFolders \u003d `\u0027${F.ADMIN_PARENT_FOLDER_ID}\u0027 in parents and mimeType\u003d\u0027application/vnd.google-apps.folder\u0027 and trashed\u003dfalse`;\r\n  const folders \u003d gdrive_list_(qFolders, \u0027files(id,name,createdTime)\u0027).files || [];\r\n  const out \u003d [];\r\n  for (const f of folders){\r\n    const qFile \u003d `\u0027${f.id}\u0027 in parents and name\u003d\u0027retell-provision.json\u0027 and trashed\u003dfalse`;\r\n    const files \u003d gdrive_list_(qFile, \u0027files(id,name,createdTime)\u0027).files || [];\r\n    if (files.length) out.push({ clientAdminFolder: f.name, recordFileId: files[0].id, recordCreatedTime: files[0].createdTime, folderCreatedTime: f.createdTime });\r\n  }\r\n  return out.sort((a,b)\u003d\u003e String(b.recordCreatedTime||\u0027\u0027).localeCompare(String(a.recordCreatedTime||\u0027\u0027)));\r\n}\r\nfunction finalizeMostRecent(){\r\n  const items \u003d listProvisionRecords();\r\n  if (!items.length) throw new Error(\u0027No provision records found under the Admin parent.\u0027);\r\n  const pick \u003d items[0];\r\n  return finalizeProvisionFromRecord(pick.recordFileId);\r\n}\r\nfunction finalizeProvisionByName(name){\r\n  name \u003d String(name||\u0027\u0027).trim();\r\n  if (!name) throw new Error(\u0027No name.\u0027);\r\n  const items \u003d listProvisionRecords();\r\n  const hit \u003d items.find(x \u003d\u003e (x.clientAdminFolder||\u0027\u0027).toLowerCase() \u003d\u003d\u003d (name+\u0027 - Admin\u0027).toLowerCase());\r\n  if (!hit) throw new Error(\u0027Admin folder for “\u0027+name+\u0027” not found under Admin parent.\u0027);\r\n  return finalizeProvisionFromRecord(hit.recordFileId);\r\n}\r\nfunction showAuthUrlsForMostRecent(){\r\n  const rec \u003d readProvisionRecord_(listProvisionRecords()[0].recordFileId);\r\n  return {\r\n    clientName: rec.client.name, slug: rec.client.slug, timestamps: rec.timestamps,\r\n    hub:     { scriptId: rec.scripts.hubScriptId,    execUrl: rec.scripts.hubExecUrl,    devUrl: (rec.scripts.hubExecUrl||\u0027\u0027).replace(/\\/exec(\\?.*)?$/,\u0027/dev\u0027),    props: rec.props.hubProps },\r\n    portal:  { scriptId: rec.scripts.portalScriptId, execUrl: rec.scripts.portalExecUrl, devUrl: (rec.scripts.portalExecUrl||\u0027\u0027).replace(/\\/exec(\\?.*)?$/,\u0027/dev\u0027), props: rec.props.portalProps },\r\n    outbound: { scriptId: rec.scripts.outboundScriptId, execUrl: rec.scripts.outboundExecUrl, devUrl: rec.scripts.outboundDevUrl, props: rec.props.outboundProps },\r\n    results:  { scriptId: rec.scripts.resultsScriptId,  execUrl: rec.scripts.resultsExecUrl,  devUrl: rec.scripts.resultsDevUrl,  props: rec.props.resultsProps  },\r\n  };\r\n}\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 4) Provision Record I/O \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// (saveProvisionRecord_, readProvisionRecord_, updateProvisionRecord_ remain the same)\r\nfunction saveProvisionRecord_(adminFolderId, recordObj){\r\n  const blob \u003d Utilities.newBlob(JSON.stringify(recordObj, null, 2), \u0027application/json\u0027, \u0027retell-provision.json\u0027);\r\n  const file \u003d DriveApp.getFolderById(adminFolderId).createFile(blob);\r\n  return file.getId();\r\n}\r\nfunction readProvisionRecord_(fileId){\r\n  const url \u003d `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileId)}?alt\u003dmedia\u0026supportsAllDrives\u003dtrue`;\r\n  const r \u003d UrlFetchApp.fetch(url, { headers:{Authorization:\u0027Bearer \u0027+_oauthToken_()}, muteHttpExceptions:true });\r\n  if (r.getResponseCode()\u003e\u003d300) throw new Error(\u0027Drive read JSON failed: \u0027 + r.getContentText());\r\n  const rec \u003d JSON.parse(r.getContentText()||\u0027{}\u0027);\r\n  rec.recordFileId \u003d fileId;\r\n  if (!rec.scripts) rec.scripts \u003d {};\r\n  if (!rec.props) rec.props \u003d {};\r\n  return rec;\r\n}\r\nfunction updateProvisionRecord_(fileId, rec){\r\n  const url \u003d `https://www.googleapis.com/upload/drive/v3/files/${encodeURIComponent(fileId)}?uploadType\u003dmedia\u0026supportsAllDrives\u003dtrue`;\r\n  const r \u003d UrlFetchApp.fetch(url, {\r\n    method:\u0027patch\u0027, contentType:\u0027application/json\u0027,\r\n    payload: JSON.stringify(rec, null, 2),\r\n    headers:{ Authorization:\u0027Bearer \u0027+_oauthToken_() }, muteHttpExceptions:true\r\n  });\r\n  if (r.getResponseCode()\u003e\u003d300) throw new Error(\u0027updateProvisionRecord_ failed: \u0027 + r.getContentText());\r\n}\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 5) Cloud Storage \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// (_createClientBucket_, _ensureBucketIamWriters_ remain the same)\r\nfunction _createClientBucket_(projectId, baseName, location) {\r\n  let name \u003d baseName.toLowerCase().replace(/[^a-z0-9\\-\\.]/g, \u0027-\u0027);\r\n  if (name.length \u003e 55) name \u003d name.slice(0, 55);\r\n  name \u003d `${name}-${_rand_().slice(0,6)}`;\r\n  const token \u003d ScriptApp.getOAuthToken();\r\n  const url   \u003d \u0027https://storage.googleapis.com/storage/v1/b?project\u003d\u0027 + encodeURIComponent(projectId);\r\n  const body  \u003d { name, location: location || \u0027us-south1\u0027, iamConfiguration:{ uniformBucketLevelAccess:{ enabled:true } }, labels:{ client:(name.split(\u0027-\u0027)[0]||\u0027client\u0027) } };\r\n  const res \u003d UrlFetchApp.fetch(url, { method:\u0027post\u0027, contentType:\u0027application/json\u0027, headers:{ Authorization:\u0027Bearer \u0027+token }, muteHttpExceptions:true, payload: JSON.stringify(body) });\r\n  if (res.getResponseCode() \u003e\u003d 300) throw new Error(\u0027Bucket create failed: HTTP \u0027+res.getResponseCode()+\u0027 \u0027+res.getContentText());\r\n  return name;\r\n}\r\nfunction _ensureBucketIamWriters_(bucket, members) {\r\n  if (!members || !members.length) return;\r\n  const token \u003d ScriptApp.getOAuthToken();\r\n  const base  \u003d \u0027https://storage.googleapis.com/storage/v1/b/\u0027 + encodeURIComponent(bucket) + \u0027/iam\u0027;\r\n  const get \u003d UrlFetchApp.fetch(base, { headers:{ Authorization:\u0027Bearer \u0027+token }, muteHttpExceptions:true });\r\n  if (get.getResponseCode() !\u003d\u003d 200) throw new Error(\u0027Get IAM policy failed: \u0027 + get.getContentText());\r\n  const policy \u003d JSON.parse(get.getContentText() || \u0027{}\u0027); policy.bindings \u003d policy.bindings || [];\r\n  const role \u003d \u0027roles/storage.objectAdmin\u0027;\r\n  let b \u003d policy.bindings.find(x \u003d\u003e x.role \u003d\u003d\u003d role); if (!b) { b \u003d { role, members: [] }; policy.bindings.push(b); }\r\n  const have \u003d new Set(b.members || []);\r\n  members.forEach(m \u003d\u003e {\r\n    const mm \u003d String(m||\u0027\u0027).trim(); if (!mm) return;\r\n    const prefixed \u003d /^serviceAccount:|^user:|^group:/.test(mm) ? mm : (mm.indexOf(\u0027@\u0027) !\u003d\u003d -1 ? (\u0027serviceAccount:\u0027 + mm) : mm);\r\n    if (!have.has(prefixed)) b.members.push(prefixed);\r\n  });\r\n  const put \u003d UrlFetchApp.fetch(base, { method:\u0027put\u0027, contentType:\u0027application/json\u0027, headers:{ Authorization:\u0027Bearer \u0027+token }, muteHttpExceptions:true, payload: JSON.stringify({ bindings: policy.bindings, etag: policy.etag }) });\r\n  if (put.getResponseCode() \u003e\u003d 300) throw new Error(\u0027Set IAM policy failed: \u0027 + put.getContentText());\r\n}\r\n\r\n// Upload a JSON object to `gs://bucket/path`\r\nfunction _writeJsonToBucket_(bucket, path, obj) {\r\n  const token \u003d ScriptApp.getOAuthToken();\r\n  const url \u003d \u0027https://storage.googleapis.com/upload/storage/v1/b/\u0027 +\r\n    encodeURIComponent(bucket) + \u0027/o?uploadType\u003dmedia\u0026name\u003d\u0027 + encodeURIComponent(path);\r\n  const res \u003d UrlFetchApp.fetch(url, {\r\n    method:\u0027post\u0027, contentType:\u0027application/json\u0027,\r\n    headers:{ Authorization:\u0027Bearer \u0027+token },\r\n    payload: JSON.stringify(obj, null, 2), muteHttpExceptions:true\r\n  });\r\n  if (res.getResponseCode() \u003e\u003d 300) throw new Error(\u0027writeJsonToBucket failed: \u0027 + res.getContentText());\r\n}\r\n\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 6) Apps Script \u0026 Drive (REST) \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// (All functions remain the same)\r\nfunction _oauthToken_(){ return ScriptApp.getOAuthToken(); }\r\n\r\n// Apps Script API\r\nfunction gas_getContent_(scriptId){\r\n  const r \u003d UrlFetchApp.fetch(`https://script.googleapis.com/v1/projects/${scriptId}/content`, { headers:{Authorization:\u0027Bearer \u0027+_oauthToken_()}, muteHttpExceptions:true });\r\n  if (r.getResponseCode()\u003e\u003d300) throw new Error(\u0027AppsScript getContent: \u0027+r.getContentText());\r\n  return JSON.parse(r.getContentText()||\u0027{}\u0027);\r\n}\r\nfunction gas_updateContent_(scriptId, files){\r\n  const r \u003d UrlFetchApp.fetch(`https://script.googleapis.com/v1/projects/${scriptId}/content`, { method:\u0027put\u0027, contentType:\u0027application/json\u0027, headers:{Authorization:\u0027Bearer \u0027+_oauthToken_()}, payload: JSON.stringify({files}), muteHttpExceptions:true });\r\n  if (r.getResponseCode()\u003e\u003d300) throw new Error(\u0027AppsScript updateContent: \u0027+r.getContentText());\r\n  return JSON.parse(r.getContentText()||\u0027{}\u0027);\r\n}\r\nfunction gas_createVersion_(scriptId, description){\r\n  const r \u003d UrlFetchApp.fetch(`https://script.googleapis.com/v1/projects/${scriptId}/versions`, { method:\u0027post\u0027, contentType:\u0027application/json\u0027, headers:{Authorization:\u0027Bearer \u0027+_oauthToken_()}, payload: JSON.stringify({description: description||(\u0027v \u0027+new Date())}), muteHttpExceptions:true });\r\n  if (r.getResponseCode()\u003e\u003d300) throw new Error(\u0027AppsScript createVersion: \u0027+r.getContentText());\r\n  return JSON.parse(r.getContentText()||\u0027{}\u0027);\r\n}\r\nfunction gas_createDeployment_(scriptId, versionNumber, description){\r\n  const r \u003d UrlFetchApp.fetch(`https://script.googleapis.com/v1/projects/${scriptId}/deployments`, { method:\u0027post\u0027, contentType:\u0027application/json\u0027, headers:{Authorization:\u0027Bearer \u0027+_oauthToken_()}, payload: JSON.stringify({versionNumber, manifestFileName:\u0027appsscript\u0027, description: description||\u0027initial\u0027}), muteHttpExceptions:true });\r\n  if (r.getResponseCode()\u003e\u003d300) throw new Error(\u0027AppsScript createDeployment: \u0027+r.getContentText());\r\n  const dep \u003d JSON.parse(r.getContentText()||\u0027{}\u0027);\r\n  // Fetch the deployment again to ensure URLs are populated\r\n  const r2 \u003d UrlFetchApp.fetch(`https://script.googleapis.com/v1/projects/${scriptId}/deployments/${dep.deploymentId}`, { headers:{Authorization:\u0027Bearer \u0027+_oauthToken_()}, muteHttpExceptions:true });\r\n  if (r2.getResponseCode()\u003e\u003d300) throw new Error(\u0027AppsScript getDeployment: \u0027+r2.getContentText());\r\n  return JSON.parse(r2.getContentText()||\u0027{}\u0027);\r\n}\r\nfunction gas_scriptsRun_(scriptId, funcName, params){\r\n  const r \u003d UrlFetchApp.fetch(`https://script.googleapis.com/v1/scripts/${scriptId}:run`, {\r\n    method:\u0027post\u0027, contentType:\u0027application/json\u0027, headers:{Authorization:\u0027Bearer \u0027+_oauthToken_()},\r\n    payload: JSON.stringify({ function: funcName, parameters: params||[], devMode:true }), muteHttpExceptions:true\r\n  });\r\n  if (r.getResponseCode()\u003e\u003d300) throw new Error(\u0027AppsScript scripts.run: \u0027+r.getContentText());\r\n  const j \u003d JSON.parse(r.getContentText()||\u0027{}\u0027);\r\n  if (j.error \u0026\u0026 j.error.details \u0026\u0026 j.error.details.length) throw new Error(j.error.details[0].errorMessage || j.error.message);\r\n  return j.response \u0026\u0026 j.response.result;\r\n}\r\n\r\n// Drive v3\r\nfunction gdrive_getFile_(fileId){\r\n  const url \u003d `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileId)}?fields\u003did,name,parents,driveId,spaces,mimeType,trashed\u0026supportsAllDrives\u003dtrue`;\r\n  const r \u003d UrlFetchApp.fetch(url, { headers:{Authorization:\u0027Bearer \u0027+_oauthToken_()}, muteHttpExceptions:true });\r\n  if (r.getResponseCode()\u003e\u003d300) throw new Error(\u0027Drive get file: \u0027+r.getContentText());\r\n  return JSON.parse(r.getContentText()||\u0027{}\u0027);\r\n}\r\nfunction gdrive_copyFile_(sourceId, newTitle, parentId){\r\n  const url \u003d `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(sourceId)}/copy?supportsAllDrives\u003dtrue\u0026fields\u003did,name,parents,driveId`;\r\n  const body \u003d parentId ? { name:newTitle, parents:[parentId] } : { name:newTitle };\r\n  const r \u003d UrlFetchApp.fetch(url, { method:\u0027post\u0027, contentType:\u0027application/json\u0027, headers:{Authorization:\u0027Bearer \u0027+_oauthToken_()}, payload: JSON.stringify(body), muteHttpExceptions:true });\r\n  if (r.getResponseCode()\u003e\u003d300) throw new Error(\u0027Drive copy failed: \u0027+r.getContentText());\r\n  const file \u003d JSON.parse(r.getContentText()||\u0027{}\u0027);\r\n  // Ensure the file is correctly placed, sometimes copy doesn\u0027t fully respect the parent parameter\r\n  if (parentId) gdrive_moveFile_(file.id, parentId);\r\n  return file;\r\n}\r\nfunction gdrive_moveFile_(fileId, targetParentId){\r\n  const meta \u003d gdrive_getFile_(fileId);\r\n  const remove \u003d (meta.parents || []).filter(p \u003d\u003e p !\u003d\u003d targetParentId).join(\u0027,\u0027);\r\n  let url \u003d `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileId)}?supportsAllDrives\u003dtrue\u0026addParents\u003d${encodeURIComponent(targetParentId)}\u0026fields\u003did,parents,driveId`;\r\n  if (remove) url +\u003d `\u0026removeParents\u003d${encodeURIComponent(remove)}`;\r\n  const r \u003d UrlFetchApp.fetch(url, { method:\u0027patch\u0027, headers:{Authorization:\u0027Bearer \u0027+_oauthToken_()}, muteHttpExceptions:true });\r\n  if (r.getResponseCode()\u003e\u003d300) throw new Error(\u0027Drive move failed: \u0027+r.getContentText());\r\n  return JSON.parse(r.getContentText()||\u0027{}\u0027);\r\n}\r\nfunction gdrive_list_(q, fields){\r\n  const url \u003d `https://www.googleapis.com/drive/v3/files?q\u003d${encodeURIComponent(q)}\u0026fields\u003d${encodeURIComponent(fields||\u0027files(id,name,parents,mimeType)\u0027)}\u0026pageSize\u003d1000\u0026spaces\u003ddrive\u0026supportsAllDrives\u003dtrue`;\r\n  const r \u003d UrlFetchApp.fetch(url, { headers:{Authorization:\u0027Bearer \u0027+_oauthToken_()}, muteHttpExceptions:true });\r\n  if (r.getResponseCode()\u003e\u003d300) throw new Error(\u0027Drive list failed: \u0027+r.getContentText());\r\n  return JSON.parse(r.getContentText()||\u0027{}\u0027);\r\n}\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 7) Bound Script Selection \u0026 Deploy \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// (listBoundScripts_, chooseBestBoundScript_, ensureBoundScriptDeploy_, retargetAndDeployBoundScripts_ remain the same)\r\n\r\nfunction listBoundScripts_(ssId){\r\n  const q \u003d `\u0027${ssId}\u0027 in parents and mimeType\u003d\u0027application/vnd.google-apps.script\u0027 and trashed\u003dfalse`;\r\n  const res \u003d gdrive_list_(q, \u0027files(id,name,createdTime,modifiedTime)\u0027);\r\n  return (res.files||[]).map(f\u003d\u003e({id:f.id, name:f.name||\u0027\u0027, createdTime:f.createdTime||\u0027\u0027, modifiedTime:f.modifiedTime||\u0027\u0027}));\r\n}\r\n\r\n/** Pick the “best” bound project (prefer the copied template over any placeholder). */\r\nfunction chooseBestBoundScript_(ssId){\r\n  const list \u003d listBoundScripts_(ssId);\r\n  if (!list.length) return null;\r\n  let best \u003d null, bestScore \u003d -1;\r\n  for (const it of list){\r\n    let score \u003d 0;\r\n    const name \u003d (it.name||\u0027\u0027).toLowerCase();\r\n    if (name.indexOf(\u0027copied:\u0027) \u003d\u003d\u003d 0) score +\u003d 30;\r\n    if (/outbound|results|console|portal/.test(name)) score +\u003d 10;\r\n    try {\r\n      const content \u003d gas_getContent_(it.id);\r\n      const files \u003d content.files || [];\r\n      const serverCount \u003d files.filter(f \u003d\u003e f.type \u003d\u003d\u003d \u0027SERVER_JS\u0027).length;\r\n      const fileNames \u003d files.map(f\u003d\u003ef.name||\u0027\u0027);\r\n      if (serverCount \u003e\u003d 2) score +\u003d 20;\r\n      // Adjust scoring slightly to accommodate the new ConfigLoader file\r\n      if ((fileNames.includes(\u0027Bootstrap\u0027) || fileNames.includes(\u0027ConfigLoader\u0027)) \u0026\u0026 serverCount \u003c\u003d 3) score -\u003d 5;\r\n      if (fileNames.some(n\u003d\u003e/ClientPortal|Console|Outbound|Results/i.test(n))) score +\u003d 10;\r\n    } catch(_) {}\r\n    if (it.createdTime) {\r\n      const age \u003d Date.now() - new Date(it.createdTime).getTime();\r\n      if (age \u003e 60000) score +\u003d 2; // older → more likely copied\r\n    }\r\n    if (score \u003e bestScore) { bestScore \u003d score; best \u003d it; }\r\n  }\r\n  return best; // {id,name}\r\n}\r\n\r\n/**\r\n * Ensure the *existing* bound script is deployed (no duplicates).\r\n * opts: { allowCreateIfMissing:boolean, waitMs:number }\r\n */\r\nfunction ensureBoundScriptDeploy_(ssId, title, tz, opts){\r\n  opts \u003d opts || {};\r\n  const allowCreate \u003d !!opts.allowCreateIfMissing;\r\n  const waitMs \u003d Math.max(0, Number(opts.waitMs || 0));\r\n\r\n  let chosen \u003d chooseBestBoundScript_(ssId);\r\n  if (!chosen \u0026\u0026 waitMs \u003e 0){\r\n    const until \u003d Date.now() + waitMs;\r\n    while (!chosen \u0026\u0026 Date.now() \u003c until){\r\n      Utilities.sleep(3000);\r\n      chosen \u003d chooseBestBoundScript_(ssId);\r\n    }\r\n  }\r\n\r\n  // Only create if explicitly allowed (we DISABLE this for Outbound/Results)\r\n  if (!chosen \u0026\u0026 allowCreate) {\r\n    const proj \u003d gas_createProject_(title || \u0027Bound App\u0027, ssId);\r\n    chosen \u003d { id: proj.scriptId, name: title || \u0027Bound App\u0027 };\r\n    waitUntilProjectExists_(chosen.id, SCRIPT_VISIBILITY_TIMEOUT_MS);\r\n  }\r\n\r\n  if (!chosen) {\r\n    Logger.log(`[WARNING] Could not find or create a bound script for spreadsheet ${ssId}. Manual intervention may be required.`);\r\n    return { scriptId: null, execUrl: \u0027\u0027, devUrl: \u0027\u0027 };\r\n  }\r\n\r\n  waitUntilProjectExists_(chosen.id, SCRIPT_VISIBILITY_TIMEOUT_MS);\r\n  _ensureWebAppManifest_(chosen.id, tz || \u0027America/Chicago\u0027, \u0027ANYONE\u0027, \u0027USER_DEPLOYING\u0027);\r\n  _ensureBootstrapFile_(chosen.id);\r\n  Utilities.sleep(300);\r\n  const dep \u003d _deployProject_(chosen.id, \u0027deploy bound\u0027);\r\n  const execUrl \u003d (dep.entryPoints||[]).filter(e\u003d\u003ee.webApp).map(e\u003d\u003ee.webApp.url)[0] || \u0027\u0027;\r\n  const devUrl  \u003d execUrl ? execUrl.replace(/\\/exec(\\?.*)?$/,\u0027/dev\u0027) : \u0027\u0027;\r\n  return { scriptId: chosen.id, execUrl, devUrl, name: chosen.name };\r\n}\r\n\r\n/** Retarget record to correct bound scripts \u0026 (re)deploy. */\r\nfunction retargetAndDeployBoundScripts_(rec){\r\n  let changed \u003d false;\r\n  const WAIT_IF_MISSING_MS \u003d 150000;\r\n\r\n  // OUTBOUND\r\n  const outboundWaitMs \u003d rec.scripts.outboundScriptId ? 0 : WAIT_IF_MISSING_MS;\r\n  const depOut \u003d ensureBoundScriptDeploy_(rec.sheets.outboundId, null, FACTORY_DEFAULTS().CT_TZ,\r\n    { allowCreateIfMissing:false, waitMs: outboundWaitMs });\r\n\r\n  if (depOut.scriptId \u0026\u0026 rec.scripts.outboundScriptId !\u003d\u003d depOut.scriptId) {\r\n    changed \u003d true;\r\n    rec.scripts.outboundScriptId \u003d depOut.scriptId;\r\n    Logger.log(\u0027Outbound script detected/retargeted: \u0027 + depOut.scriptId);\r\n    // NEW: Re-inject loader if the script ID changed\r\n    injectConfigLoaderForBound_(depOut.scriptId, \u0027Outbound\u0027);\r\n  }\r\n  if (depOut.scriptId \u0026\u0026 depOut.execUrl \u0026\u0026 rec.scripts.outboundExecUrl !\u003d\u003d depOut.execUrl) {\r\n    changed \u003d true;\r\n    rec.scripts.outboundExecUrl \u003d depOut.execUrl;\r\n    rec.scripts.outboundDevUrl \u003d depOut.devUrl;\r\n  }\r\n\r\n  // RESULTS\r\n  const resultsWaitMs \u003d rec.scripts.resultsScriptId ? 0 : WAIT_IF_MISSING_MS;\r\n  const depRes \u003d ensureBoundScriptDeploy_(rec.sheets.resultsId, null, FACTORY_DEFAULTS().CT_TZ,\r\n    { allowCreateIfMissing:false, waitMs: resultsWaitMs });\r\n\r\n  if (depRes.scriptId \u0026\u0026 rec.scripts.resultsScriptId !\u003d\u003d depRes.scriptId) {\r\n    changed \u003d true;\r\n    rec.scripts.resultsScriptId \u003d depRes.scriptId;\r\n    Logger.log(\u0027Results script detected/retargeted: \u0027 + depRes.scriptId);\r\n    // NEW: Re-inject loader if the script ID changed\r\n    injectConfigLoaderForBound_(depRes.scriptId, \u0027Results\u0027);\r\n  }\r\n  if (depRes.scriptId \u0026\u0026 depRes.execUrl \u0026\u0026 rec.scripts.resultsExecUrl !\u003d\u003d depRes.execUrl) {\r\n    changed \u003d true;\r\n    rec.scripts.resultsExecUrl \u003d depRes.execUrl;\r\n    rec.scripts.resultsDevUrl \u003d depRes.devUrl;\r\n  }\r\n\r\n  if (changed \u0026\u0026 rec.recordFileId) {\r\n    try { updateProvisionRecord_(rec.recordFileId, rec); } catch(e){ Logger.log(\u0027updateProvisionRecord_ failed: \u0027+e); }\r\n  }\r\n}\r\n\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 8) Bootstrap injection \u0026 Deploy helpers \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// (All functions remain the same)\r\nfunction _ensureWebAppManifest_(scriptId, tz, access, executeAs) {\r\n  const content \u003d gas_getContent_(scriptId);\r\n  const files \u003d content.files || [];\r\n  let mf \u003d files.find(f \u003d\u003e f.name \u003d\u003d\u003d \u0027appsscript\u0027 \u0026\u0026 f.type \u003d\u003d\u003d \u0027JSON\u0027);\r\n  if (!mf) { mf \u003d { name: \u0027appsscript\u0027, type: \u0027JSON\u0027, source: \u0027{}\u0027 }; files.push(mf); }\r\n  let j \u003d {}; try { j \u003d JSON.parse(mf.source || \u0027{}\u0027); } catch (_) { j \u003d {}; }\r\n  j.timeZone \u003d j.timeZone || tz || \u0027America/Chicago\u0027;\r\n  j.runtimeVersion \u003d \u0027V8\u0027;\r\n  j.exceptionLogging \u003d j.exceptionLogging || \u0027STACKDRIVER\u0027;\r\n  j.webapp \u003d j.webapp || {};\r\n  j.webapp.access \u003d access || \u0027ANYONE\u0027;\r\n  j.webapp.executeAs \u003d executeAs || \u0027USER_DEPLOYING\u0027;\r\n  mf.source \u003d JSON.stringify(j, null, 2);\r\n  gas_updateContent_(scriptId, files);\r\n}\r\n\r\nfunction _ensureBootstrapFile_(scriptId) {\r\n  const content \u003d gas_getContent_(scriptId);\r\n  const files \u003d content.files || [];\r\n  // Check if already present and up to date\r\n  const existing \u003d files.find(f \u003d\u003e f.name \u003d\u003d\u003d \u0027Bootstrap\u0027 \u0026\u0026 f.type \u003d\u003d\u003d \u0027SERVER_JS\u0027);\r\n  const source \u003d getBootstrapSource_();\r\n\r\n  if (existing \u0026\u0026 existing.source \u003d\u003d\u003d source) {\r\n    return; // Already present and correct\r\n  }\r\n\r\n  // Remove old version if exists\r\n  for (let i \u003d files.length - 1; i \u003e\u003d 0; i--) {\r\n    if (files[i].name \u003d\u003d\u003d \u0027Bootstrap\u0027) files.splice(i, 1);\r\n  }\r\n\r\n  files.push({ name: \u0027Bootstrap\u0027, type: \u0027SERVER_JS\u0027, source });\r\n  gas_updateContent_(scriptId, files);\r\n  _createVersionIfPossible_(scriptId, \u0027post-bootstrap\u0027);\r\n}\r\n\r\n// NEW: Centralized source for Bootstrap.gs\r\nfunction getBootstrapSource_() {\r\n    return `\r\nfunction __bootstrapApplyProps_(p){\r\n  try{\r\n    var P \u003d PropertiesService.getScriptProperties();\r\n    P.setProperties(p||{}, true);\r\n    P.setProperty(\u0027BOOTSTRAPPED\u0027,\u00271\u0027);\r\n    return {ok:true, keys:Object.keys(p||{}).length};\r\n  }catch(e){ return {ok:false, error:String(e)}; }\r\n}\r\nfunction __bootstrapSetProps(p){ return __bootstrapApplyProps_(p); }\r\nfunction __bootstrapGetProps(keys){\r\n  try{\r\n    var P \u003d PropertiesService.getScriptProperties();\r\n    var all \u003d P.getProperties();\r\n    if (Object.prototype.toString.call(keys)\u003d\u003d\u003d\u0027[object Array]\u0027 \u0026\u0026 keys.length){\r\n      var out \u003d {}; keys.forEach(function(k){ if (all.hasOwnProperty(k)) out[k]\u003dall[k]; });\r\n      return out;\r\n    }\r\n    return all;\r\n  }catch(e){ return {ok:false, error:String(e)}; }\r\n}\r\n\r\nfunction doGet(e) {\r\n  try{\r\n    if (e \u0026\u0026 e.parameter \u0026\u0026 e.parameter.apply) {\r\n      var json \u003d Utilities.newBlob(Utilities.base64DecodeWebSafe(e.parameter.apply)).getDataAsString();\r\n      var props \u003d JSON.parse(json);\r\n      var r \u003d __bootstrapApplyProps_(props);\r\n      return ContentService.createTextOutput(JSON.stringify(r)).setMimeType(ContentService.MimeType.JSON);\r\n    }\r\n    if (e \u0026\u0026 e.parameter \u0026\u0026 e.parameter.ping) {\r\n      var want \u003d [];\r\n      try {\r\n        if (e.parameter.want) {\r\n          var wjson \u003d Utilities.newBlob(Utilities.base64DecodeWebSafe(e.parameter.want)).getDataAsString();\r\n          want \u003d JSON.parse(wjson);\r\n        }\r\n      } catch(_) {}\r\n      var P \u003d PropertiesService.getScriptProperties();\r\n      var all \u003d P.getProperties();\r\n      var has \u003d {};\r\n      (want||[]).forEach(function(k){ has[k] \u003d !!all[k]; });\r\n      return ContentService.createTextOutput(JSON.stringify({\r\n        ok:true, authorized:true, anyProps:Object.keys(all||{}).length\u003e0, hasProps:has\r\n      })).setMimeType(ContentService.MimeType.JSON);\r\n    }\r\n  }catch(err){\r\n    return ContentService.createTextOutput(JSON.stringify({ok:false,error:String(err)})).setMimeType(ContentService.MimeType.JSON);\r\n  }\r\n  if (typeof doGetHandler \u003d\u003d\u003d \u0027function\u0027) return doGetHandler(e);\r\n  return ContentService.createTextOutput(\"Script deployed. If you see this, authorization succeeded.\").setMimeType(ContentService.MimeType.TEXT);\r\n}\r\n\r\nvar __orig_doPost \u003d (typeof doPostHandler \u003d\u003d\u003d \u0027function\u0027) ? doPostHandler : null;\r\nfunction doPost(e){\r\n  try{\r\n    var P \u003d PropertiesService.getScriptProperties();\r\n    var initialized \u003d !!(P.getProperty(\u0027CLIENT_TOKEN\u0027) || P.getProperty(\u0027BOOTSTRAPPED\u0027));\r\n    if (!initialized) {\r\n      var body \u003d e \u0026\u0026 e.postData \u0026\u0026 e.postData.contents ? JSON.parse(e.postData.contents) : {};\r\n      if (body \u0026\u0026 body.__bootstrapProps) {\r\n        var r \u003d __bootstrapApplyProps_(body.__bootstrapProps);\r\n        return ContentService.createTextOutput(JSON.stringify(r)).setMimeType(ContentService.MimeType.JSON);\r\n      }\r\n    }\r\n  }catch(err){}\r\n  if (__orig_doPost) return __orig_doPost(e);\r\n  return ContentService.createTextOutput(JSON.stringify({ok:false,error:\u0027No handler\u0027})).setMimeType(ContentService.MimeType.JSON);\r\n}\r\n`;\r\n}\r\n\r\n\r\nfunction _deployProject_(scriptId, description) {\r\n  const v \u003d gas_createVersion_(scriptId, description || (\u0027v \u0027 + new Date()));\r\n  return gas_createDeployment_(scriptId, v.versionNumber, description || \u0027initial\u0027);\r\n}\r\nfunction waitUntilProjectExists_(scriptId, timeoutMs) {\r\n  const max \u003d timeoutMs || SCRIPT_VISIBILITY_TIMEOUT_MS;\r\n  const start \u003d Date.now(); let lastErr \u003d null;\r\n  while (Date.now() - start \u003c max) {\r\n    try { gas_getContent_(scriptId); return; } catch (e) { lastErr \u003d e; Utilities.sleep(1000); }\r\n  }\r\n  // Only throw if the timeout is significant, otherwise just log warning\r\n  if (max \u003e 10000) {\r\n    throw new Error(\u0027New script not visible yet: \u0027 + scriptId + (lastErr ? \u0027 — \u0027 + lastErr : \u0027\u0027));\r\n  } else {\r\n    Logger.log(\u0027Warning: Script not immediately visible: \u0027 + scriptId);\r\n  }\r\n}\r\nfunction _createVersionIfPossible_(scriptId, desc) { try { gas_createVersion_(scriptId, desc || \u0027bootstrap\u0027); } catch (e) {} }\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 9) Web bootstrap helpers \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// (All functions remain the same)\r\nfunction _setPropsViaWebApp_(webUrl, props) {\r\n  if (!webUrl) return { ok: false, reason: \u0027no_url\u0027 };\r\n  try {\r\n    // Warm up the web app instance\r\n    UrlFetchApp.fetch(webUrl + (webUrl.indexOf(\u0027?\u0027)\u003e-1?\u0027\u0026\u0027:\u0027?\u0027) + \u0027ping\u003d\u0027 + Math.random(), { muteHttpExceptions:true, followRedirects:true });\r\n  } catch(_) {}\r\n  try {\r\n    const r \u003d UrlFetchApp.fetch(webUrl, {\r\n      method:\u0027post\u0027, contentType:\u0027application/json\u0027,\r\n      payload: JSON.stringify({ __bootstrapProps: props }),\r\n      followRedirects:true, muteHttpExceptions:true\r\n    });\r\n    const code \u003d r.getResponseCode();\r\n    if (code \u003e\u003d 200 \u0026\u0026 code \u003c 300) {\r\n      const text \u003d String(r.getContentText()||\u0027\u0027).trim();\r\n      if (text.startsWith(\u0027\u003c\u0027)) return { ok: false, reason: \u0027auth\u0027 }; // auth HTML\r\n      try {\r\n        const j \u003d JSON.parse(text);\r\n        return { ok: !!(j \u0026\u0026 j.ok \u003d\u003d\u003d true) };\r\n      } catch {\r\n        return { ok: false, reason: \u0027json_parse\u0027 };\r\n      }\r\n    }\r\n    return { ok: false, reason: `http_${code}` };\r\n  } catch(e) {\r\n    Logger.log(\u0027UrlFetch failed in _setPropsViaWebApp_: \u0027 + e);\r\n    return { ok: false, reason: \u0027exception\u0027 };\r\n  }\r\n}\r\nfunction _safeSetScriptProps_(scriptId, props, label) {\r\n  label \u003d label || \u0027script\u0027;\r\n  waitUntilProjectExists_(scriptId, SCRIPT_VISIBILITY_TIMEOUT_MS);\r\n  _ensureBootstrapFile_(scriptId);\r\n\r\n  // MODIFIED: Increased backoff delays to be more patient with Execution API propagation.\r\n  const backoff \u003d [5000, 15000, 30000, 60000, 60000];\r\n  let lastErr \u003d null, notFoundCount \u003d 0;\r\n\r\n  for (let i\u003d0;i\u003cbackoff.length;i++) {\r\n    try {\r\n      return gas_scriptsRun_(scriptId, \u0027__bootstrapSetProps\u0027, [props]);\r\n    } catch (e) {\r\n      lastErr \u003d e;\r\n      const msg \u003d String(e \u0026\u0026 e.message || e);\r\n      Logger.log(`Execution API fallback attempt ${i+1}.0 failed: ${msg}`);\r\n\r\n      if (msg.includes(\u0027\"code\": 404\u0027) || /NOT_FOUND|Requested entity was not found/i.test(msg)) {\r\n        if (++notFoundCount \u003e 4) throw new Error(`Execution API could not find project ${scriptId} after multiple attempts (propagation). Try Finalize again.`);\r\n      } else if (/Function not found|__bootstrapSetProps|is not defined/i.test(msg)) {\r\n        _createVersionIfPossible_(scriptId, \u0027retry-setprops-\u0027+(i+1));\r\n      } else {\r\n        throw new Error(label + \u0027 setProps error (unrecoverable): \u0027 + msg);\r\n      }\r\n      Utilities.sleep(backoff[i]);\r\n    }\r\n  }\r\n  throw new Error(\u0027Could not set props in \u0027 + label + \u0027 (\u0027 + scriptId + \u0027) after retries: \u0027 + (lastErr \u0026\u0026 lastErr.message || lastErr));\r\n}\r\nfunction _pingWebAppStatus_(webUrl, keys){\r\n  if (!webUrl) return null;\r\n  try {\r\n    const wantB64 \u003d Utilities.base64EncodeWebSafe(JSON.stringify(keys||[]));\r\n    const url \u003d webUrl + (webUrl.indexOf(\u0027?\u0027)\u003e-1?\u0027\u0026\u0027:\u0027?\u0027) + \u0027ping\u003d1\u0026want\u003d\u0027+wantB64 + \u0027\u0026ts\u003d\u0027 + Date.now();\r\n    const r \u003d UrlFetchApp.fetch(url, { followRedirects:true, muteHttpExceptions:true });\r\n    if (r.getResponseCode() \u003e\u003d 200 \u0026\u0026 r.getResponseCode() \u003c 300) {\r\n      const text \u003d String(r.getContentText()||\u0027\u0027).trim();\r\n      if (text.startsWith(\u0027\u003c\u0027)) return { authorized:false, hasProps:{} };\r\n      try { const j \u003d JSON.parse(text); return { authorized: !!(j \u0026\u0026 j.ok), hasProps: (j \u0026\u0026 j.hasProps) || {} }; }\r\n      catch(_) { return { authorized:true, hasProps:{} }; }\r\n    }\r\n  } catch (e) { Logger.log(\u0027_pingWebAppStatus_ failed for %s: %s\u0027, webUrl, e); }\r\n  return null;\r\n}\r\n\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 10) Sheet skeletons \u0026 protections \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// (All functions remain the same)\r\nfunction _ensureOutboundSkeleton_(ssId){\r\n  const ss \u003d SpreadsheetApp.openById(ssId);\r\n  let shL \u003d ss.getSheetByName(\u0027Outbound Leads\u0027); if (!shL) shL \u003d ss.insertSheet(\u0027Outbound Leads\u0027);\r\n  let shC \u003d ss.getSheetByName(\u0027Credit\u0027);         if (!shC) shC \u003d ss.insertSheet(\u0027Credit\u0027);\r\n  const OUT_HEADERS \u003d [\u0027First Name\u0027,\u0027Last Name\u0027,\u0027Phone\u0027,\u0027Address\u0027,\u0027City\u0027,\u0027State\u0027,\u0027Zip\u0027,\u0027Email\u0027,\u0027Run\u0027,\u0027Last Call\u0027,\u0027Next Call\u0027];\r\n  if (shL.getLastRow() \u003d\u003d\u003d 0) shL.getRange(1,1,1,OUT_HEADERS.length).setValues([OUT_HEADERS]);\r\n  if (!shC.getRange(\u0027B1\u0027).getValue()) shC.getRange(\u0027B1\u0027).setValue(0);\r\n  // Ensure the ledger headers exist starting from A3, matching the Hub\u0027s expectations\r\n  if (shC.getLastRow() \u003c 3) shC.getRange(\u0027A3:C3\u0027).setValues([[\u0027Date\u0027,\u0027Calls Sent\u0027,\u0027Credits Refunded\u0027]]);\r\n}\r\nfunction _ensureResultsSkeleton_(ssId){\r\n  const ss \u003d SpreadsheetApp.openById(ssId);\r\n  const tabs \u003d [\u0027Good Leads\u0027,\u0027Good Leads For Later\u0027,\u0027Bad Leads\u0027,\u0027Not Interested Leads\u0027];\r\n  const HEAD \u003d [\r\n    \u0027Date\u0027,\u0027First Name\u0027,\u0027Last Name\u0027,\u0027Phone\u0027,\u0027Address\u0027,\u0027City\u0027,\u0027Input State\u0027,\u0027State Given\u0027,\u0027Zip\u0027,\r\n    \u0027Input Email\u0027,\u0027Email Given\u0027,\u0027Accredited\u0027,\u0027Interested\u0027,\u0027New Investments\u0027,\u0027Liquid To Invest\u0027,\r\n    \u0027Job\u0027,\u0027Follow Up\u0027,\u0027Summery\u0027,\u0027Quality\u0027,\u0027Recording\u0027,\u0027Call Time\u0027,\u0027Correct Name\u0027,\u0027DNC\u0027,\r\n    \u0027Disconnection Reason\u0027,\u0027Run\u0027\r\n  ];\r\n  tabs.forEach(t\u003d\u003e{ let sh \u003d ss.getSheetByName(t); if (!sh) sh \u003d ss.insertSheet(t); if (sh.getLastRow() \u003d\u003d\u003d 0) sh.getRange(1,1,1,HEAD.length).setValues([HEAD]); });\r\n}\r\nfunction _ensureArchiveSheet_(ssId){\r\n  const ss \u003d SpreadsheetApp.openById(ssId);\r\n  let archive \u003d ss.getSheetByName(\u0027Archive\u0027); if (!archive) archive \u003d ss.insertSheet(\u0027Archive\u0027);\r\n  // Clean up default sheets if they exist\r\n  ss.getSheets().forEach(s \u003d\u003e {\r\n    if (s.getSheetId() !\u003d\u003d archive.getSheetId() \u0026\u0026 /Sheet\\d+/.test(s.getName())) {\r\n        ss.deleteSheet(s);\r\n    }\r\n  });\r\n  const HEAD \u003d [\r\n    \u0027Date\u0027,\u0027First Name\u0027,\u0027Last Name\u0027,\u0027Phone\u0027,\u0027Address\u0027,\u0027City\u0027,\u0027Input State\u0027,\u0027State Given\u0027,\u0027Zip\u0027,\r\n    \u0027Input Email\u0027,\u0027Email Given\u0027,\u0027Accredited\u0027,\u0027Interested\u0027,\u0027New Investments\u0027,\u0027Liquid To Invest\u0027,\r\n    \u0027Past Experience\u0027,\u0027Job\u0027,\u0027Follow Up\u0027,\u0027Summary\u0027,\u0027Quality\u0027,\u0027Recording\u0027,\u0027Call Time\u0027,\u0027Correct Name\u0027,\r\n    \u0027DNC\u0027,\u0027Disconnection Reason\u0027,\u0027Run\u0027,\u0027Next Call Date\u0027\r\n  ];\r\n  const rng \u003d archive.getRange(1,1,1,HEAD.length);\r\n  const current \u003d rng.getValues()[0];\r\n  const needsHeaders \u003d current.length !\u003d\u003d HEAD.length || HEAD.some((h,i)\u003d\u003e current[i] !\u003d\u003d h);\r\n  if (needsHeaders) {\r\n    // Only clear and set if necessary, to avoid disrupting existing data if structure is okay\r\n    if (archive.getLastRow() \u003d\u003d\u003d 0 || archive.getLastRow() \u003d\u003d\u003d 1) {\r\n        archive.clear();\r\n        archive.getRange(1,1,1,HEAD.length).setValues([HEAD]);\r\n    }\r\n  }\r\n}\r\nfunction protectHeaders_(ssId, editors) {\r\n  const ss \u003d SpreadsheetApp.openById(ssId);\r\n  ss.getSheets().forEach(sh \u003d\u003e {\r\n    if (sh.getMaxColumns() \u003d\u003d\u003d 0) return;\r\n    const rng \u003d sh.getRange(1, 1, 1, Math.max(1, sh.getMaxColumns()));\r\n    const p \u003d rng.protect().setDescription(`Lock header: ${sh.getName()}`).setWarningOnly(false);\r\n    try { p.removeEditors(p.getEditors()); } catch (_) {}\r\n    if (editors \u0026\u0026 editors.length) p.addEditors(editors);\r\n  });\r\n}\r\nfunction protectCreditSheet_(ssId, editors) {\r\n  const ss \u003d SpreadsheetApp.openById(ssId);\r\n  const sh \u003d ss.getSheetByName(\u0027Credit\u0027); if (!sh) return;\r\n  const pSheet \u003d sh.protect().setDescription(\u0027Lock Credit sheet\u0027).setWarningOnly(false);\r\n  try { pSheet.removeEditors(pSheet.getEditors()); } catch (_) {}\r\n  if (editors \u0026\u0026 editors.length) pSheet.addEditors(editors);\r\n  // Protect the balance cell B1 specifically\r\n  const pB1 \u003d sh.getRange(\u0027B1\u0027).protect().setDescription(\u0027Editable: B1\u0027).setWarningOnly(false);\r\n  try { pB1.removeEditors(pB1.getEditors()); } catch (_) {}\r\n  if (editors \u0026\u0026 editors.length) pB1.addEditors(editors);\r\n}\r\nfunction protectArchive_(ssId, editors) {\r\n  protectHeaders_(ssId, editors);\r\n  const ss \u003d SpreadsheetApp.openById(ssId);\r\n  const sh \u003d ss.getSheetByName(\u0027Archive\u0027); if (!sh) return;\r\n  const p \u003d sh.protect().setDescription(\u0027Archive — protect\u0027).setWarningOnly(true);\r\n  try { p.removeEditors(p.getEditors()); } catch (_) {}\r\n  if (editors \u0026\u0026 editors.length) p.addEditors(editors);\r\n}\r\n\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 11) Web UI (Step 1 \u0026 Step 2 + Mini Status Card) \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// MODIFIED: Updated instructions and output display for the new workflow.\r\nfunction doGet() {\r\n  const html \u003d `\r\n\u003c!DOCTYPE html\u003e\u003chtml\u003e\u003chead\u003e\u003cmeta name\u003d\"viewport\" content\u003d\"width\u003ddevice-width,initial-scale\u003d1\"/\u003e\r\n\u003ctitle\u003eProvision New Client\u003c/title\u003e\r\n\u003cstyle\u003e\r\n  body{font:14px/1.5 system-ui,Arial;margin:0;background:#f6f7fb;color:#111}\r\n  .wrap{max-width:980px;margin:0 auto;padding:24px}\r\n  .card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:16px 18px;box-shadow:0 2px 12px rgba(0,0,0,.06);margin:0 0 18px}\r\n  h1{font-size:20px;margin:0 0 10px;font-weight:800}\r\n  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}\r\n  @media(max-width:860px){.grid{grid-template-columns:1fr}}\r\n  label{display:block;font-size:12px;color:#64748b;margin:8px 0 4px}\r\n  input,textarea{width:100%;padding:9px;border:1px solid #e5e7eb;border-radius:8px;box-sizing:border-box;}\r\n  .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}\r\n  .btn{margin-top:12px;background:#111;color:#fff;border:none;border-radius:10px;padding:12px 18px;font-weight:800;cursor:pointer}\r\n  .btn:disabled{background:#999;cursor:not-allowed}\r\n  .muted{color:#64748b;font-size:12px;margin-top:6px}\r\n  pre{background:#0b1220;color:#d1e7ff;border-radius:10px;padding:10px;overflow:auto;font-size:11px;}\r\n  a{word-break:break-all;color:#0057e7}\r\n  .ok{color:#0a7b12;font-weight:700}\r\n  .bad{color:#b00020;font-weight:700}\r\n  .warn{color:#b45309;font-weight:700}\r\n  #status-area { margin-top: 16px; padding: 12px; border-radius: 10px; background: #f3f4f6; border: 1px solid #e5e7eb; }\r\n  .instructions{background:#eef2ff;border:1px solid #c7d2fe;border-radius:10px;padding:14px;margin-bottom:18px;}\r\n\u003c/style\u003e\r\n\u003c/head\u003e\u003cbody\u003e\u003cdiv class\u003d\"wrap\"\u003e\r\n  \u003cdiv class\u003d\"instructions\"\u003e\r\n    \u003ch2\u003eHow to Provision a Client (Async Workflow)\u003c/h2\u003e\r\n    \u003col\u003e\r\n      \u003cli\u003eFill out the form below and click \"Start Provisioning\".\u003c/li\u003e\r\n      \u003cli\u003eThe process will start in the background. The Record ID will be displayed.\u003c/li\u003e\r\n      \u003cli\u003eThe UI will automatically poll for status updates. Wait for it to show \"COMPLETED\".\u003c/li\u003e\r\n      \u003cli\u003eOnce complete, the final authorization links will be displayed. Follow the authorization steps as before.\u003c/li\u003e\r\n    \u003c/ol\u003e\r\n  \u003c/div\u003e\r\n\r\n  \u003cdiv class\u003d\"card\"\u003e\r\n    \u003ch1\u003eClient Provisioning\u003c/h1\u003e\r\n    \u003cdiv class\u003d\"grid\"\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eClient Name\u003c/label\u003e\u003cinput id\u003d\"clientName\" placeholder\u003d\"Acme Metals\"/\u003e\u003c/div\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eSlug (auto if blank)\u003c/label\u003e\u003cinput id\u003d\"slug\" placeholder\u003d\"acme\"/\u003e\u003c/div\u003e\r\n      \u003cdiv\u003e\u003clabel\u003ePortal Password\u003c/label\u003e\u003cinput id\u003d\"portalPassword\" placeholder\u003d\"changeme\"/\u003e\u003c/div\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eClient Token (auto if blank)\u003c/label\u003e\u003cinput id\u003d\"clientToken\" placeholder\u003d\"tok_xxx\"/\u003e\u003c/div\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eAllowed Emails (comma)\u003c/label\u003e\u003cinput id\u003d\"allowedEmails\" placeholder\u003d\"ops@you.com, client@them.com\"/\u003e\u003c/div\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eShare Client Folder With (comma)\u003c/label\u003e\u003cinput id\u003d\"shareWith\" placeholder\u003d\"client@them.com\"/\u003e\u003c/div\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eRetell API Key\u003c/label\u003e\u003cinput id\u003d\"retellKey\" placeholder\u003d\"key_xxx\"/\u003e\u003c/div\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eRetell API URL\u003c/label\u003e\u003cinput id\u003d\"retellApiUrl\" value\u003d\"https://api.retellai.com/v1/calls/batch\"/\u003e\u003c/div\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eBucket Writers (comma)\u003c/label\u003e\u003cinput id\u003d\"bucketWriters\" value\u003d\"${DEFAULT_BUCKET_WRITER}\"/\u003e\u003c/div\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eAgent IDs (1..8, comma)\u003c/label\u003e\u003cinput id\u003d\"agents\" placeholder\u003d\"agent1,agent2,agent3,agent4,agent5,agent6,agent7,agent8\"/\u003e\u003c/div\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eFrom Numbers (1..8, comma)\u003c/label\u003e\u003cinput id\u003d\"froms\" placeholder\u003d\"+1...,+1...,+1...,+1...,+1...,+1...,+1...,+1...\"/\u003e\u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class\u003d\"row\"\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eRecall Days — No Answer\u003c/label\u003e\u003cinput id\u003d\"daysNoAns\" type\u003d\"number\" value\u003d\"5\"/\u003e\u003c/div\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eRecall Days — Answered/Later\u003c/label\u003e\u003cinput id\u003d\"daysAns\" type\u003d\"number\" value\u003d\"30\"/\u003e\u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class\u003d\"row\"\u003e\r\n      \u003cdiv\u003e\u003clabel\u003eAuto‑Finalize after (minutes)\u003c/label\u003e\u003cinput id\u003d\"finalizeDelay\" type\u003d\"number\" value\u003d\"${DEFAULT_FINALIZE_DELAY_MIN}\"/\u003e\u003c/div\u003e\r\n      \u003cdiv\u003e\u003clabel style\u003d\"margin-top:18px;\"\u003e\u003cinput id\u003d\"autoFinalize\" type\u003d\"checkbox\" checked/\u003e Auto‑Finalize? (Backup)\u003c/label\u003e\u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cbutton id\u003d\"btnCreate\" class\u003d\"btn\" onclick\u003d\"create()\"\u003eStart Provisioning\u003c/button\u003e\r\n    \u003cdiv class\u003d\"muted\" id\u003d\"msg1\"\u003e\u003c/div\u003e\r\n    \u003cdiv id\u003d\"status-area\" style\u003d\"display:none;\"\u003e\r\n        \u003ch3\u003eProvisioning Status\u003c/h3\u003e\r\n        \u003cp\u003eRecord ID: \u003ccode id\u003d\"recordIdText\"\u003e\u003c/code\u003e\u003c/p\u003e\r\n        \u003cp\u003eStatus: \u003cstrong id\u003d\"statusText\"\u003e\u003c/strong\u003e\u003c/p\u003e\r\n        \u003cdiv id\u003d\"error-area\" style\u003d\"display:none;\"\u003e\r\n            \u003cp class\u003d\"bad\"\u003eError: \u003cspan id\u003d\"errorText\"\u003e\u003c/span\u003e\u003c/p\u003e\r\n        \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv id\u003d\"out1\" style\u003d\"margin-top:8px;\"\u003e\u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/div\u003e\r\n\u003cscript\u003e\r\nvar statusInterval \u003d null;\r\n\r\nfunction parseCSV(s){return (s||\u0027\u0027).split(\u0027,\u0027).map(x\u003d\u003ex.trim()).filter(Boolean);}\r\n\r\nfunction create(){\r\n  document.getElementById(\u0027btnCreate\u0027).disabled \u003d true;\r\n  if (statusInterval) clearInterval(statusInterval);\r\n\r\n  const agents \u003d parseCSV(document.getElementById(\u0027agents\u0027).value);\r\n  const froms  \u003d parseCSV(document.getElementById(\u0027froms\u0027).value);\r\n  const payload \u003d {\r\n    clientName: document.getElementById(\u0027clientName\u0027).value,\r\n    slug: document.getElementById(\u0027slug\u0027).value,\r\n    portalPassword: document.getElementById(\u0027portalPassword\u0027).value,\r\n    clientToken: document.getElementById(\u0027clientToken\u0027).value,\r\n    allowedEmails: parseCSV(document.getElementById(\u0027allowedEmails\u0027).value),\r\n    shareWith: parseCSV(document.getElementById(\u0027shareWith\u0027).value),\r\n    retellApiKey: document.getElementById(\u0027retellKey\u0027).value,\r\n    retellApiUrl: document.getElementById(\u0027retellApiUrl\u0027).value,\r\n    agents: {1:agents[0]||\u0027\u0027,2:agents[1]||\u0027\u0027,3:agents[2]||\u0027\u0027,4:agents[3]||\u0027\u0027,5:agents[4]||\u0027\u0027,6:agents[5]||\u0027\u0027,7:agents[6]||\u0027\u0027,8:agents[7]||\u0027\u0027},\r\n    fromNumbers: {1:froms[0]||\u0027\u0027,2:froms[1]||\u0027\u0027,3:froms[2]||\u0027\u0027,4:froms[3]||\u0027\u0027,5:froms[4]||\u0027\u0027,6:froms[5]||\u0027\u0027,7:froms[6]||\u0027\u0027,8:froms[7]||\u0027\u0027},\r\n    recallDays: { noAnswer: Number(document.getElementById(\u0027daysNoAns\u0027).value||5),\r\n                  answered: Number(document.getElementById(\u0027daysAns\u0027).value||30) },\r\n    bucketWriters: parseCSV(document.getElementById(\u0027bucketWriters\u0027).value),\r\n    finalizeDelayMin: Number(document.getElementById(\u0027finalizeDelay\u0027).value||${DEFAULT_FINALIZE_DELAY_MIN}),\r\n    autoFinalize: document.getElementById(\u0027autoFinalize\u0027).checked\r\n  };\r\n  document.getElementById(\u0027msg1\u0027).textContent \u003d \u0027Starting provisioning process...\u0027;\r\n  document.getElementById(\u0027out1\u0027).innerHTML \u003d \u0027\u0027;\r\n  document.getElementById(\u0027status-area\u0027).style.display \u003d \u0027none\u0027;\r\n\r\n  google.script.run\r\n    .withSuccessHandler(showProvisioningStarted)\r\n    .withFailureHandler(err \u003d\u003e {\r\n      document.getElementById(\u0027msg1\u0027).textContent \u003d \u0027Error: \u0027 + (err \u0026\u0026 err.message ? err.message : err);\r\n      document.getElementById(\u0027btnCreate\u0027).disabled \u003d false;\r\n    })\r\n    .startProvisioning(payload);\r\n}\r\n\r\nfunction showProvisioningStarted(res) {\r\n  document.getElementById(\u0027btnCreate\u0027).disabled \u003d false;\r\n  if (!res || !res.ok) {\r\n    document.getElementById(\u0027msg1\u0027).textContent \u003d \u0027Failed to start provisioning: \u0027 + (res.message || \u0027Unknown error\u0027);\r\n    return;\r\n  }\r\n  document.getElementById(\u0027msg1\u0027).textContent \u003d res.message;\r\n\r\n  const recordId \u003d res.recordFileId;\r\n  document.getElementById(\u0027recordIdText\u0027).textContent \u003d recordId;\r\n  document.getElementById(\u0027status-area\u0027).style.display \u003d \u0027block\u0027;\r\n\r\n  pollStatus(recordId); // Start polling\r\n  statusInterval \u003d setInterval(() \u003d\u003e pollStatus(recordId), 10000); // Poll every 10 seconds\r\n}\r\n\r\nfunction pollStatus(recordId) {\r\n    google.script.run\r\n        .withSuccessHandler(showStatus)\r\n        .withFailureHandler(err \u003d\u003e {\r\n            console.error(\"Polling failed:\", err);\r\n            document.getElementById(\u0027statusText\u0027).textContent \u003d \u0027POLLING FAILED\u0027;\r\n            document.getElementById(\u0027statusText\u0027).className \u003d \u0027bad\u0027;\r\n        })\r\n        .getProvisioningStatus(recordId);\r\n}\r\n\r\nfunction showStatus(res) {\r\n    if (!res || !res.ok) {\r\n        document.getElementById(\u0027statusText\u0027).textContent \u003d res.error || \u0027Failed to get status\u0027;\r\n        document.getElementById(\u0027statusText\u0027).className \u003d \u0027bad\u0027;\r\n        if (statusInterval) clearInterval(statusInterval);\r\n        return;\r\n    }\r\n\r\n    const status \u003d res.status;\r\n    document.getElementById(\u0027statusText\u0027).textContent \u003d status;\r\n    document.getElementById(\u0027statusText\u0027).className \u003d (status \u003d\u003d\u003d \u0027COMPLETED\u0027 ? \u0027ok\u0027 : (status \u003d\u003d\u003d \u0027FAILED\u0027 ? \u0027bad\u0027 : \u0027warn\u0027));\r\n\r\n    if (res.error) {\r\n        document.getElementById(\u0027error-area\u0027).style.display \u003d \u0027block\u0027;\r\n        document.getElementById(\u0027errorText\u0027).textContent \u003d res.error;\r\n    } else {\r\n        document.getElementById(\u0027error-area\u0027).style.display \u003d \u0027none\u0027;\r\n    }\r\n\r\n    if (status \u003d\u003d\u003d \u0027COMPLETED\u0027 || status \u003d\u003d\u003d \u0027FAILED\u0027) {\r\n        if (statusInterval) clearInterval(statusInterval);\r\n        if (status \u003d\u003d\u003d \u0027COMPLETED\u0027 \u0026\u0026 res.finalUrls) {\r\n            renderFinalOutput(res.finalUrls);\r\n        }\r\n    }\r\n}\r\n\r\nfunction renderFinalOutput(urls) {\r\n  const link \u003d (url, txt) \u003d\u003e url ? \u0027\u003ca target\u003d\"_blank\" href\u003d\"\u0027+url+\u0027\"\u003e\u0027+(txt||url)+\u0027\u003c/a\u003e\u0027 : \u0027(not ready)\u0027;\r\n  const s \u003d urls;\r\n  const html \u003d\r\n    \u0027\u003ch4\u003e\u003cspan class\u003d\"ok\"\u003eSUCCESS:\u003c/span\u003e Provisioning is complete. Now follow the authorization steps.\u003c/h4\u003e\u0027 +\r\n    \u0027\u003ch4\u003e1. Authorize \u0026 Configure Standalone Scripts (Editors)\u003c/h4\u003e\u0027+\r\n    \u0027\u003cp\u003eOpen the editor, Authorize (Run ▶️), then select/run \u003ccode\u003emanualConfigFromProvisionRecord\u003c/code\u003e.\u003c/p\u003e\u0027+\r\n    \u0027\u003cul\u003e\u0027+\r\n    \u0027\u003cli\u003e\u003cb\u003eHub Auth/Editor: \u0027 + link(s.hubAuthUrl) + \u0027\u003c/b\u003e \u003cspan class\u003d\"bad\"\u003e← Authorize \u0026 Run Config Loader\u003c/span\u003e\u003c/li\u003e\u0027 +\r\n    \u0027\u003cli\u003e\u003cb\u003ePortal Auth/Editor: \u0027 + link(s.portalAuthUrl) + \u0027\u003c/b\u003e \u003cspan class\u003d\"bad\"\u003e← Authorize \u0026 Run Config Loader\u003c/span\u003e\u003c/li\u003e\u0027 +\r\n    \u0027\u003cli\u003eHub exec: \u0027 + link(s.hubExecUrl) + \u0027\u003c/li\u003e\u0027 +\r\n    \u0027\u003cli\u003ePortal exec: \u0027 + link(s.portalExecUrl) + \u0027\u003c/li\u003e\u0027 +\r\n    \u0027\u003c/ul\u003e\u0027+\r\n    \u0027\u003ch4\u003e2. Authorize \u0026 Configure Bound Scripts (Sheets)\u003c/h4\u003e\u0027+\r\n    \u0027\u003cp\u003eOpen the sheet, Authorize (Extensions \u003e Apps Script \u003e Run ▶️), then use the \"🛠️ Config\" menu in the Sheet.\u003c/p\u003e\u0027+\r\n    \u0027\u003cul\u003e\u0027+\r\n    \u0027\u003cli\u003e\u003cb\u003eOutbound Sheet: \u0027 + link(s.outboundAuthUrl) + \u0027\u003c/b\u003e \u003cspan class\u003d\"bad\"\u003e← Authorize \u0026 Use Config Menu\u003c/span\u003e\u003c/li\u003e\u0027 +\r\n    \u0027\u003cli\u003e\u003cb\u003eResults Sheet: \u0027  + link(s.resultsAuthUrl) + \u0027\u003c/b\u003e \u003cspan class\u003d\"bad\"\u003e← Authorize \u0026 Use Config Menu\u003c/span\u003e\u003c/li\u003e\u0027 +\r\n    \u0027\u003c/ul\u003e\u0027+\r\n    \u0027\u003chr/\u003e\u003ch4\u003eFull JSON Output\u003c/h4\u003e\u003cpre\u003e\u0027+JSON.stringify(s.record, null, 2)+\u0027\u003c/pre\u003e\u0027;\r\n\r\n  document.getElementById(\u0027out1\u0027).innerHTML \u003d html;\r\n}\r\n\u003c/script\u003e\r\n\u003c/body\u003e\u003c/html\u003e`;\r\n  return HtmlService.createHtmlOutput(html).setTitle(\u0027Provision New Client\u0027);\r\n}\r\n\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 12) Mini Status — Server \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// (getStatusForRecord remains the same)\r\nfunction getStatusForRecord(recordFileId){\r\n  if (!recordFileId) throw new Error(\u0027recordFileId required for status\u0027);\r\n  const rec \u003d readProvisionRecord_(recordFileId);\r\n\r\n  // Make sure our record points to the best bound scripts and has deploy URLs\r\n  retargetAndDeployBoundScripts_(rec);\r\n\r\n  const hubUrl    \u003d rec.scripts.hubExecUrl || \u0027\u0027;\r\n  const portalUrl \u003d rec.scripts.portalExecUrl || \u0027\u0027;\r\n  const hubDev    \u003d hubUrl    ? hubUrl.replace(/\\/exec(\\?.*)?$/,\u0027/dev\u0027)    : \u0027\u0027;\r\n  const portalDev \u003d portalUrl ? portalUrl.replace(/\\/exec(\\?.*)?$/,\u0027/dev\u0027) : \u0027\u0027;\r\n\r\n  // Check status via web pings (most reliable way to check authorization and properties)\r\n  const hubPing    \u003d _pingWebAppStatus_(hubDev, HUB_VERIFY_KEYS)      || _pingWebAppStatus_(hubUrl, HUB_VERIFY_KEYS)      || { authorized:false, hasProps:{} };\r\n  const portalPing \u003d _pingWebAppStatus_(portalDev, PORTAL_VERIFY_KEYS) || _pingWebAppStatus_(portalUrl, PORTAL_VERIFY_KEYS) || { authorized:false, hasProps:{} };\r\n\r\n  const outExec \u003d rec.scripts.outboundExecUrl || \u0027\u0027;\r\n  const outDev  \u003d rec.scripts.outboundDevUrl  || \u0027\u0027;\r\n  const resExec \u003d rec.scripts.resultsExecUrl  || \u0027\u0027;\r\n  const resDev  \u003d rec.scripts.resultsDevUrl   || \u0027\u0027;\r\n  const outboundPing \u003d _pingWebAppStatus_(outDev, OUTBOUND_VERIFY_KEYS) || _pingWebAppStatus_(outExec, OUTBOUND_VERIFY_KEYS) || { authorized:false, hasProps:{} };\r\n  const resultsPing  \u003d _pingWebAppStatus_(resDev, RESULTS_VERIFY_KEYS)  || _pingWebAppStatus_(resExec, RESULTS_VERIFY_KEYS)  || { authorized:false, hasProps:{} };\r\n\r\n  return { ok:true, hub:hubPing, portal:portalPing, outbound:outboundPing, results:resultsPing };\r\n}\r\n\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 13) Credit Ledger \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// (appendCreditLedgerRow_ remains the same)\r\nfunction appendCreditLedgerRow_(ssId, row) {\r\n  const ss \u003d SpreadsheetApp.openById(ssId);\r\n  const sh \u003d ss.getSheetByName(\u0027Credits\u0027);\r\n  if (!sh) {\r\n    console.warn(`Credit Ledger sheet \u0027Credits\u0027 not found in spreadsheet ${ssId}. Skipping.`);\r\n    return;\r\n  }\r\n  const HEAD \u003d [\u0027Client\u0027,\u0027Amount Paid\u0027,\u0027Credits Given\u0027,\u0027Client Sheet\u0027,\u0027Client Token\u0027,\u0027Admin Token\u0027,\u0027Hub URL\u0027];\r\n  const cur  \u003d sh.getRange(1,1,1,HEAD.length).getValues()[0];\r\n  if (HEAD.some((h,i)\u003d\u003e (cur[i]||\u0027\u0027)!\u003d\u003dh)) sh.getRange(1,1,1,HEAD.length).setValues([HEAD]);\r\n  const values \u003d [\r\n    row.client || \u0027\u0027,\r\n    Number(row.amountPaid || 0),\r\n    Number(row.creditsGiven || 0),\r\n    row.outboundId || \u0027\u0027,\r\n    row.clientToken || \u0027\u0027,\r\n    row.adminToken || \u0027\u0027,\r\n    row.hubUrl || \u0027\u0027,\r\n  ];\r\n  sh.getRange(sh.getLastRow()+1, 1, 1, HEAD.length).setValues([values]);\r\n}\r\n\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 14) Utilities \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n// (gas_createProject_, _rand_ remain the same)\r\nfunction gas_createProject_(title, parentId){\r\n  const url \u003d \u0027https://script.googleapis.com/v1/projects\u0027;\r\n  const body \u003d { title: String(title||\u0027Bound App\u0027), parentId: String(parentId||\u0027\u0027) };\r\n  const r \u003d UrlFetchApp.fetch(url, {\r\n    method:\u0027post\u0027, contentType:\u0027application/json\u0027, muteHttpExceptions:true,\r\n    headers:{ Authorization:\u0027Bearer \u0027+_oauthToken_() },\r\n    payload: JSON.stringify(body)\r\n  });\r\n  if (r.getResponseCode() \u003e\u003d 300) throw new Error(\u0027AppsScript projects.create failed: \u0027 + r.getContentText());\r\n  return JSON.parse(r.getContentText()||\u0027{}\u0027); // { scriptId, ... }\r\n}\r\nfunction _rand_(){ return Math.random().toString(36).slice(2) + Math.random().toString(36).slice(2); }\r\n\r\n\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 15) NEW: Config Loader Injection \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n\r\n/** Source code for the ConfigLoader.gs file */\r\nfunction getConfigLoaderSource_() {\r\n  return `\r\n/**\r\n * Config Loader (top-level; works in stand-alone editors and bound sheets)\r\n * Usage:\r\n *   • Run manualConfigAuto()                     — auto-detects the matching retell-provision.json\r\n *   • Or run manualConfigFromProvisionRecord(\u0027\u003cDrive URL or File ID\u003e\u0027)\r\n * Behavior:\r\n *   • Merges Script Properties (does not wipe others)\r\n *   • Writes PROVISION_RECORD_ID and RECORD_ID for future zero‑arg runs\r\n *\r\n * Requires scopes (manifest):\r\n *   https://www.googleapis.com/auth/drive.readonly\r\n *   https://www.googleapis.com/auth/script.external_request\r\n *   (optional) https://www.googleapis.com/auth/userinfo.email\r\n */\r\n\r\n/** ───────────────────────── Helpers ───────────────────────── **/\r\n\r\n/** Extract a Drive File ID from a raw id or a full Drive URL. */\r\nfunction __cfg_parseRecordArg(arg) {\r\n  var a \u003d String(arg || \u0027\u0027).trim();\r\n  if (!a) return \u0027\u0027;\r\n  if (/^[A-Za-z0-9_-]{20,}$/.test(a)) return a;         // already looks like an id\r\n  var m \u003d a.match(/[-\\\\w]{25,}/g);                       // first long-ish token from URL\r\n  return (m \u0026\u0026 m[0]) ? m[0] : \u0027\u0027;\r\n}\r\n\r\n/**\r\n * Drive-wide scan (most recent first) to find a provision file that references *this* script id.\r\n * Tight bounds for speed; adequate for typical libraries.\r\n */\r\nfunction __cfg_autoFindRecordId() {\r\n  var token \u003d ScriptApp.getOAuthToken();\r\n  var q \u003d \"name\u003d\u0027retell-provision.json\u0027 and trashed\u003dfalse\";\r\n  var pageToken \u003d null, examined \u003d 0;\r\n\r\n  for (var page \u003d 0; page \u003c 5; page++) {\r\n    var url \u003d \"https://www.googleapis.com/drive/v3/files\"\r\n            + \"?q\u003d\" + encodeURIComponent(q)\r\n            + \"\u0026fields\u003dfiles(id,name,modifiedTime),nextPageToken\"\r\n            + \"\u0026orderBy\u003dmodifiedTime desc\"\r\n            + \"\u0026pageSize\u003d100\"\r\n            + (pageToken ? \"\u0026pageToken\u003d\"+encodeURIComponent(pageToken) : \"\")\r\n            + \"\u0026includeItemsFromAllDrives\u003dtrue\u0026supportsAllDrives\u003dtrue\";\r\n\r\n    var r \u003d UrlFetchApp.fetch(url, { headers:{ Authorization:\"Bearer \" + token }, muteHttpExceptions:true });\r\n    if (r.getResponseCode() \u003e\u003d 300) break;\r\n\r\n    var j \u003d JSON.parse(r.getContentText() || \"{}\");\r\n    var arr \u003d j.files || [];\r\n    for (var i\u003d0; i\u003carr.length \u0026\u0026 examined\u003c400; i++) {\r\n      examined++;\r\n      var fid \u003d arr[i].id;\r\n      try {\r\n        var res \u003d UrlFetchApp.fetch(\r\n          \"https://www.googleapis.com/drive/v3/files/\" + encodeURIComponent(fid) + \"?alt\u003dmedia\u0026supportsAllDrives\u003dtrue\",\r\n          { headers:{ Authorization:\"Bearer \" + token }, muteHttpExceptions:true }\r\n        );\r\n        if (res.getResponseCode() \u003e\u003d 300) continue;\r\n\r\n        var rec \u003d JSON.parse(res.getContentText() || \"{}\");\r\n        var myId \u003d ScriptApp.getScriptId();\r\n        var s \u003d (rec \u0026\u0026 rec.scripts) || {};\r\n        if (s.hubScriptId\u003d\u003d\u003dmyId || s.portalScriptId\u003d\u003d\u003dmyId || s.outboundScriptId\u003d\u003d\u003dmyId || s.resultsScriptId\u003d\u003d\u003dmyId) {\r\n          return fid;\r\n        }\r\n      } catch (_) {}\r\n    }\r\n    pageToken \u003d j.nextPageToken;\r\n    if (!pageToken) break;\r\n  }\r\n  return \"\";\r\n}\r\n\r\n/** Download the provision record JSON via Drive v3 media endpoint. */\r\nfunction __cfg_fetchRecord(fileId) {\r\n  var token \u003d ScriptApp.getOAuthToken();\r\n  var resp \u003d UrlFetchApp.fetch(\r\n    \"https://www.googleapis.com/drive/v3/files/\" + encodeURIComponent(fileId) + \"?alt\u003dmedia\u0026supportsAllDrives\u003dtrue\",\r\n    { headers:{ Authorization:\"Bearer \" + token }, muteHttpExceptions:true }\r\n  );\r\n  if (resp.getResponseCode() \u003e\u003d 300) {\r\n    throw new Error(\"Failed to download provision record: HTTP \" + resp.getResponseCode() + \" \" + resp.getContentText());\r\n  }\r\n  return JSON.parse(resp.getContentText() || \"{}\");\r\n}\r\n\r\n/** ─────────────────── Main: load \u0026 apply ─────────────────── **/\r\n\r\n/** Zero-argument convenience: select this in the editor and click Run ▶︎ */\r\nfunction manualConfigAuto() {\r\n  return manualConfigFromProvisionRecord(\u0027\u0027);\r\n}\r\n\r\n/**\r\n * Load from a specific File ID or full Drive URL; if omitted, auto-detect.\r\n * @param {string\u003d} recordFileIdOrUrl\r\n */\r\nfunction manualConfigFromProvisionRecord(recordFileIdOrUrl) {\r\n  // 1) Resolve the record id\r\n  var id \u003d __cfg_parseRecordArg(recordFileIdOrUrl);\r\n\r\n  // Prefer an id already stored on this script\r\n  if (!id) {\r\n    try {\r\n      var P0 \u003d PropertiesService.getScriptProperties();\r\n      id \u003d P0.getProperty(\u0027PROVISION_RECORD_ID\u0027) || P0.getProperty(\u0027RECORD_ID\u0027) || \u0027\u0027;\r\n    } catch (_) {}\r\n  }\r\n\r\n  // Auto-detect as next best\r\n  if (!id) id \u003d __cfg_autoFindRecordId();\r\n\r\n  // In a bound Sheet, give the user a prompt as a last resort\r\n  if (!id \u0026\u0026 typeof SpreadsheetApp!\u003d\u003d\u0027undefined\u0027 \u0026\u0026 SpreadsheetApp.getUi) {\r\n    try {\r\n      var ui \u003d SpreadsheetApp.getUi();\r\n      var res \u003d ui.prompt(\r\n        \u0027Paste the Provision Record link (or ID)\u0027,\r\n        \u0027Tip: you can paste the full Drive URL – no need to extract the ID.\u0027,\r\n        ui.ButtonSet.OK_CANCEL\r\n      );\r\n      if (res.getSelectedButton() \u003d\u003d\u003d ui.Button.OK) {\r\n        id \u003d __cfg_parseRecordArg(res.getResponseText());\r\n      }\r\n    } catch(_) {}\r\n  }\r\n\r\n  if (!id) {\r\n    var msg \u003d \"Could not locate a matching \u0027retell-provision.json\u0027. Ensure it exists and you have access.\";\r\n    Logger.log(msg);\r\n    if (typeof SpreadsheetApp!\u003d\u003d\u0027undefined\u0027 \u0026\u0026 SpreadsheetApp.getUi) { try{ SpreadsheetApp.getUi().alert(msg); }catch(_){} }\r\n    return { ok:false, error: msg };\r\n  }\r\n\r\n  // 2) Fetch record \u0026 determine role for this script\r\n  var rec \u003d __cfg_fetchRecord(id);\r\n  if (!rec.scripts || !rec.props) {\r\n    var e2 \u003d \"Provision record missing \u0027scripts\u0027 or \u0027props\u0027.\";\r\n    Logger.log(e2);\r\n    return { ok:false, error: e2 };\r\n  }\r\n\r\n  var myScriptId \u003d ScriptApp.getScriptId();\r\n  var role \u003d \"Unknown\", props \u003d null;\r\n\r\n  if (rec.scripts.hubScriptId \u003d\u003d\u003d myScriptId)           { role\u003d\"Hub\";     props\u003drec.props.hubProps; }\r\n  else if (rec.scripts.portalScriptId \u003d\u003d\u003d myScriptId)   { role\u003d\"Portal\";  props\u003drec.props.portalProps; }\r\n  else if (rec.scripts.outboundScriptId \u003d\u003d\u003d myScriptId) { role\u003d\"Outbound\"; props\u003drec.props.outboundProps; }\r\n  else if (rec.scripts.resultsScriptId \u003d\u003d\u003d myScriptId)  { role\u003d\"Results\";  props\u003drec.props.resultsProps; }\r\n\r\n  // Fallback for bound Sheets (match active spreadsheet id)\r\n  if (!props \u0026\u0026 typeof SpreadsheetApp!\u003d\u003d\u0027undefined\u0027 \u0026\u0026 SpreadsheetApp.getActiveSpreadsheet) {\r\n    try {\r\n      var ssId \u003d SpreadsheetApp.getActiveSpreadsheet().getId();\r\n      if (rec.sheets \u0026\u0026 rec.sheets.outboundId \u003d\u003d\u003d ssId) { role\u003d\"Outbound (ID Match)\"; props\u003drec.props.outboundProps; }\r\n      else if (rec.sheets \u0026\u0026 rec.sheets.resultsId \u003d\u003d\u003d ssId) { role\u003d\"Results (ID Match)\"; props\u003drec.props.resultsProps; }\r\n    } catch(_) {}\r\n  }\r\n\r\n  if (!props) {\r\n    var e3 \u003d \"This script ID (\" + myScriptId + \") did not match any script in the provision record.\";\r\n    Logger.log(e3);\r\n    if (typeof SpreadsheetApp!\u003d\u003d\u0027undefined\u0027 \u0026\u0026 SpreadsheetApp.getUi) { try{ SpreadsheetApp.getUi().alert(e3); }catch(_){} }\r\n    return { ok:false, error: e3 };\r\n  }\r\n\r\n  // 3) Apply properties (merge) and remember the record id\r\n  try {\r\n    var P \u003d PropertiesService.getScriptProperties();\r\n    P.setProperties(props, false);            // merge (append) keys safely\r\n    P.setProperty(\u0027BOOTSTRAPPED\u0027,\u00271\u0027);\r\n    P.setProperty(\u0027PROVISION_RECORD_ID\u0027, id); // remember for zero‑arg runs\r\n    P.setProperty(\u0027RECORD_ID\u0027, id);\r\n\r\n    var count \u003d Object.keys(props).length;\r\n    var msgOk \u003d \"Applied \" + count + \" properties for role \" + role + \" (record \" + id + \").\";\r\n    Logger.log(msgOk);\r\n    if (typeof SpreadsheetApp!\u003d\u003d\u0027undefined\u0027 \u0026\u0026 SpreadsheetApp.getUi) { try{ SpreadsheetApp.getUi().alert(msgOk); }catch(_){} }\r\n    return { ok:true, message: msgOk, count: count, role: role, recordId: id };\r\n  } catch (e) {\r\n    var e4 \u003d \"Failed to apply Script Properties: \" + e;\r\n    Logger.log(e4);\r\n    return { ok:false, error: e4 };\r\n  }\r\n}\r\n`;\r\n}\r\n\r\n/** Inject ConfigLoader.gs into Standalone scripts (Hub/Portal) */\r\nfunction injectConfigLoader_(scriptId) {\r\n  const content \u003d gas_getContent_(scriptId);\r\n  const files \u003d content.files || [];\r\n\r\n  // Remove previous loader if exists\r\n  for (let i \u003d files.length - 1; i \u003e\u003d 0; i--) {\r\n    if (files[i].name \u003d\u003d\u003d \u0027ConfigLoader\u0027) files.splice(i, 1);\r\n  }\r\n\r\n  // Add the new loader file\r\n  files.push({\r\n    name: \u0027ConfigLoader\u0027,\r\n    type: \u0027SERVER_JS\u0027,\r\n    source: getConfigLoaderSource_()\r\n  });\r\n\r\n  // Ensure manifest scopes include Drive read + external request (standalone editors)\r\n  let mf \u003d files.find(f \u003d\u003e f.name \u003d\u003d\u003d \u0027appsscript\u0027 \u0026\u0026 f.type \u003d\u003d\u003d \u0027JSON\u0027);\r\n  if (mf) {\r\n    let j \u003d JSON.parse(mf.source || \u0027{}\u0027);\r\n    j.oauthScopes \u003d j.oauthScopes || [];\r\n    const need \u003d [\r\n      \"https://www.googleapis.com/auth/drive.readonly\",\r\n      \"https://www.googleapis.com/auth/script.external_request\",\r\n      \"https://www.googleapis.com/auth/userinfo.email\"\r\n    ];\r\n    need.forEach(s \u003d\u003e { if (!j.oauthScopes.includes(s)) j.oauthScopes.push(s); });\r\n    mf.source \u003d JSON.stringify(j, null, 2);\r\n  }\r\n\r\n  gas_updateContent_(scriptId, files);\r\n}\r\n\r\n/** Inject ConfigLoader.gs and update onOpen for Bound scripts (Outbound/Results) */\r\nfunction injectConfigLoaderForBound_(scriptId, type) {\r\n  const content \u003d gas_getContent_(scriptId);\r\n  const files \u003d content.files || [];\r\n\r\n  // 1. Inject the ConfigLoader file\r\n  for (let i \u003d files.length - 1; i \u003e\u003d 0; i--) {\r\n    if (files[i].name \u003d\u003d\u003d \u0027ConfigLoader\u0027) files.splice(i, 1);\r\n  }\r\n  files.push({\r\n    name: \u0027ConfigLoader\u0027,\r\n    type: \u0027SERVER_JS\u0027,\r\n    source: getConfigLoaderSource_()\r\n  });\r\n\r\n  // 2. Find or create the primary file to modify\r\n  let primaryFile \u003d null;\r\n  let primaryFileName \u003d \u0027\u0027;\r\n  const placeholderSource \u003d `/**\r\n * Placeholder file created by provisioning process.\r\n */\r\nfunction onOpen() {\r\n  // The provisioning process will modify this function to add required menus.\r\n}\r\n`;\r\n\r\n  if (type \u003d\u003d\u003d \u0027Outbound\u0027) {\r\n    primaryFileName \u003d \u0027Counts\u0027;\r\n  } else if (type \u003d\u003d\u003d \u0027Results\u0027) {\r\n    primaryFileName \u003d \u0027Code\u0027;\r\n  }\r\n\r\n  primaryFile \u003d files.find(f \u003d\u003e f.name \u003d\u003d\u003d primaryFileName \u0026\u0026 f.type \u003d\u003d\u003d \u0027SERVER_JS\u0027);\r\n\r\n  if (!primaryFile) {\r\n    Logger.log(`Primary file (\u0027${primaryFileName}.gs\u0027) not found for injection in ${type} script ${scriptId}. Creating it.`);\r\n    primaryFile \u003d {\r\n      name: primaryFileName,\r\n      type: \u0027SERVER_JS\u0027,\r\n      source: placeholderSource\r\n    };\r\n    files.push(primaryFile);\r\n  }\r\n\r\n  // 3. Modify the onOpen function in the primary file\r\n  // Backup existing onOpen -\u003e originalOnOpen (if not already done)\r\n  if (!/function\\s+originalOnOpen\\s*\\(\\)/.test(primaryFile.source)) {\r\n    primaryFile.source \u003d primaryFile.source.replace(\r\n      /function\\s+onOpen\\s*\\(\\)/g,\r\n      \u0027// Backup of original menu logic\\nfunction originalOnOpen()\u0027\r\n    );\r\n  }\r\n\r\n  // Append our unified onOpen once\r\n  if (!primaryFile.source.includes(\u0027// Unified onOpen for Configuration\u0027)) {\r\n    primaryFile.source +\u003d `\r\n// Unified onOpen for Configuration\r\nfunction onOpen() {\r\n  if (typeof originalOnOpen \u003d\u003d\u003d \u0027function\u0027) {\r\n    try { originalOnOpen(); } catch(e) { Logger.log(\u0027Error running originalOnOpen: \u0027 + e); }\r\n  }\r\n  try {\r\n    SpreadsheetApp.getUi()\r\n      .createMenu(\u0027🛠️ Config\u0027)\r\n      .addItem(\u0027Load Config from Record\u0027, \u0027manualConfigFromProvisionRecord\u0027)\r\n      .addToUi();\r\n  } catch(e) { Logger.log(\u0027Error creating Config menu: \u0027 + e); }\r\n}\r\n`;\r\n  }\r\n\r\n  // 4. Ensure manifest scopes include Drive read + external request + UI\r\n  let mf \u003d files.find(f \u003d\u003e f.name \u003d\u003d\u003d \u0027appsscript\u0027 \u0026\u0026 f.type \u003d\u003d\u003d \u0027JSON\u0027);\r\n  if (!mf) { // If no manifest exists, create one. This shouldn\u0027t happen but is safe.\r\n      mf \u003d { name: \u0027appsscript\u0027, type: \u0027JSON\u0027, source: \u0027{}\u0027 };\r\n      files.push(mf);\r\n  }\r\n\r\n  let j \u003d {};\r\n  try { j \u003d JSON.parse(mf.source || \u0027{}\u0027); } catch(e) { j \u003d {}; }\r\n\r\n  j.oauthScopes \u003d j.oauthScopes || [];\r\n  const need \u003d [\r\n    \"https://www.googleapis.com/auth/drive.readonly\",\r\n    \"https://www.googleapis.com/auth/script.external_request\",\r\n    \"https://www.googleapis.com/auth/script.container.ui\",\r\n    \"https://www.googleapis.com/auth/spreadsheets.currentonly\"\r\n  ];\r\n  need.forEach(s \u003d\u003e { if (!j.oauthScopes.includes(s)) j.oauthScopes.push(s); });\r\n  mf.source \u003d JSON.stringify(j, null, 2);\r\n\r\n\r\n  gas_updateContent_(scriptId, files);\r\n}\r\n\r\n\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 16) NEW: Config trigger endpoints \u0026 Record-ID pushers \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n\r\n// Push the Provision Record ID into each target script via Execution API bootstrap (handy post-authorization)\r\nfunction pushRecordIdToScripts(recordFileId){\r\n  if (!recordFileId) throw new Error(\u0027recordFileId required.\u0027);\r\n  const rec \u003d readProvisionRecord_(recordFileId);\r\n  const payload \u003d { PROVISION_RECORD_ID: recordFileId, RECORD_ID: recordFileId };\r\n  const out \u003d {};\r\n  const pairs \u003d [\r\n    [\u0027hub\u0027,     rec.scripts.hubScriptId],\r\n    [\u0027portal\u0027,  rec.scripts.portalScriptId],\r\n    [\u0027outbound\u0027,rec.scripts.outboundScriptId],\r\n    [\u0027results\u0027, rec.scripts.resultsScriptId]\r\n  ];\r\n  pairs.forEach(([k,id])\u003d\u003e{\r\n    if (!id) { out[k] \u003d { ok:false, error:\u0027No scriptId\u0027 }; return; }\r\n    try { _safeSetScriptProps_(id, payload, k); out[k] \u003d { ok:true }; }\r\n    catch(e){ out[k] \u003d { ok:false, error:String(e) }; }\r\n  });\r\n  return { ok:true, results: out };\r\n}\r\n\r\n// Helpers to trigger manualConfigFromProvisionRecord in each script\r\nfunction runConfigAll(recordFileId){\r\n  if (!recordFileId) throw new Error(\u0027recordFileId required.\u0027);\r\n  const rec \u003d readProvisionRecord_(recordFileId);\r\n  return {\r\n    hub:     runConfigLoaderFor_(rec.scripts.hubScriptId,      recordFileId),\r\n    portal:  runConfigLoaderFor_(rec.scripts.portalScriptId,   recordFileId),\r\n    outbound:runConfigLoaderFor_(rec.scripts.outboundScriptId, recordFileId),\r\n    results: runConfigLoaderFor_(rec.scripts.resultsScriptId,  recordFileId),\r\n  };\r\n}\r\nfunction runConfigHub(recordFileId){ return runConfigForRole_(recordFileId, \u0027hub\u0027); }\r\nfunction runConfigPortal(recordFileId){ return runConfigForRole_(recordFileId, \u0027portal\u0027); }\r\nfunction runConfigOutbound(recordFileId){ return runConfigForRole_(recordFileId, \u0027outbound\u0027); }\r\nfunction runConfigResults(recordFileId){ return runConfigForRole_(recordFileId, \u0027results\u0027); }\r\n\r\nfunction runConfigForRole_(recordFileId, which){\r\n  if (!recordFileId) throw new Error(\u0027recordFileId required.\u0027);\r\n  const rec \u003d readProvisionRecord_(recordFileId);\r\n  const map \u003d { hub:rec.scripts.hubScriptId, portal:rec.scripts.portalScriptId, outbound:rec.scripts.outboundScriptId, results:rec.scripts.resultsScriptId };\r\n  const id \u003d map[which];\r\n  return runConfigLoaderFor_(id, recordFileId);\r\n}\r\nfunction runConfigLoaderFor_(scriptId, recordFileId){\r\n  if (!scriptId) return { ok:false, error:\u0027No scriptId\u0027 };\r\n  try {\r\n    const res \u003d gas_scriptsRun_(scriptId, \u0027manualConfigFromProvisionRecord\u0027, [recordFileId]);\r\n    return { ok:true, result:res||{} };\r\n  } catch(e){\r\n    return { ok:false, error:String(e) };\r\n  }\r\n}\r\n\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 19) NEW: Code Injection \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n\r\n/** Source code for the WebhookIngestMap polling functions */\r\nfunction getWebhookPollingSource_() {\r\n  return `\r\n// \u003d\u003d\u003d 5) Polling Trigger \u003d\u003d\u003d\r\n\r\nconst INGEST_TRIGGER_FUNCTION_NAME \u003d \u0027hubIngestWebhooks_\u0027;\r\n\r\n/**\r\n * Deletes any existing trigger for the ingest function.\r\n */\r\nfunction _deleteIngestTrigger() {\r\n  try {\r\n    const triggers \u003d ScriptApp.getProjectTriggers();\r\n    for (const trigger of triggers) {\r\n      if (trigger.getHandlerFunction() \u003d\u003d\u003d INGEST_TRIGGER_FUNCTION_NAME) {\r\n        ScriptApp.deleteTrigger(trigger);\r\n      }\r\n    }\r\n  } catch (e) {\r\n    console.error(\u0027Error deleting trigger for \u0027 + INGEST_TRIGGER_FUNCTION_NAME + \u0027: \u0027 + e.toString());\r\n  }\r\n}\r\n\r\n/**\r\n * Starts a time-based trigger to poll for webhook results every 5 minutes.\r\n * This function is intended to be called after a run is finalized.\r\n */\r\nfunction startWebhookIngestPolling_() {\r\n  _deleteIngestTrigger(); // Ensure no duplicate triggers\r\n  ScriptApp.newTrigger(INGEST_TRIGGER_FUNCTION_NAME)\r\n    .timeBased()\r\n    .everyMinutes(5)\r\n    .create();\r\n  console.log(\u0027POLLING: Webhook ingest polling started. Will run every 5 minutes.\u0027);\r\n}\r\n`;\r\n}\r\n\r\n/** Inject Webhook Polling logic into a script */\r\nfunction injectWebhookPolling_(scriptId) {\r\n  const content \u003d gas_getContent_(scriptId);\r\n  const files \u003d content.files || [];\r\n\r\n  // Find the Hub_ArchiveAndResults.js file\r\n  let ingestFile \u003d files.find(f \u003d\u003e f.name \u003d\u003d\u003d \u0027Hub_ArchiveAndResults\u0027 \u0026\u0026 f.type \u003d\u003d\u003d \u0027SERVER_JS\u0027);\r\n\r\n  if (ingestFile) {\r\n    // Append the polling source code to the existing file\r\n    if (!ingestFile.source.includes(\u0027// \u003d\u003d\u003d 5) Polling Trigger \u003d\u003d\u003d\u0027)) {\r\n      ingestFile.source +\u003d \u0027\\\\n\u0027 + getWebhookPollingSource_();\r\n      gas_updateContent_(scriptId, files);\r\n      Logger.log(\u0027Injected webhook polling logic into Hub_ArchiveAndResults.gs for script \u0027 + scriptId);\r\n    } else {\r\n      Logger.log(\u0027Webhook polling logic already exists in Hub_ArchiveAndResults.gs for script \u0027 + scriptId);\r\n    }\r\n  } else {\r\n    // If the file doesn\u0027t exist, we can\u0027t inject. Log a warning.\r\n    // This indicates a problem with the Hub template.\r\n    Logger.log(\u0027WARNING: Could not find Hub_ArchiveAndResults.gs in script \u0027 + scriptId + \u0027. Cannot inject polling logic.\u0027);\r\n  }\r\n}\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 17) NEW: Provisioning State Machine \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n\r\nconst PROVISION_TRIGGER_HANDLER \u003d \u0027runProvisioningStateMachine\u0027;\r\n\r\n/**\r\n * Cancels any existing provisioning triggers to prevent duplicate runs.\r\n */\r\nfunction _cancelProvisioningTriggers_() {\r\n  const trigs \u003d ScriptApp.getProjectTriggers();\r\n  (trigs || []).filter(t \u003d\u003e t.getHandlerFunction \u0026\u0026 t.getHandlerFunction() \u003d\u003d\u003d PROVISION_TRIGGER_HANDLER)\r\n               .forEach(t \u003d\u003e { try { ScriptApp.deleteTrigger(t); } catch(_){} });\r\n}\r\n\r\n/**\r\n * Schedules the next step of the provisioning process to run after a short delay.\r\n * @param {string} recordId - The Drive File ID of the provisioning record.\r\n * @param {string} nextStep - The name of the next state to execute.\r\n */\r\nfunction _scheduleNextStep_(recordId, nextStep) {\r\n  _cancelProvisioningTriggers_(); // Ensure no other triggers are pending\r\n\r\n  // Store the record ID and the target step in Script Properties for the trigger to access\r\n  const P \u003d PropertiesService.getScriptProperties();\r\n  P.setProperty(\u0027PROVISION_RECORD_ID\u0027, recordId);\r\n  P.setProperty(\u0027PROVISION_NEXT_STEP\u0027, nextStep);\r\n\r\n  // Create a trigger to run the state machine in ~15 seconds.\r\n  // This delay gives APIs time to catch up (e.g., file creation propagation).\r\n  const when \u003d new Date(Date.now() + 15 * 1000);\r\n  try {\r\n    ScriptApp.newTrigger(PROVISION_TRIGGER_HANDLER).timeBased().at(when).create();\r\n    Logger.log(`Scheduled next step: \u0027${nextStep}\u0027 for record ${recordId}`);\r\n  } catch (e) {\r\n    Logger.log(`Trigger creation failed for step \u0027${nextStep}\u0027: ${e}`);\r\n    const rec \u003d readProvisionRecord_(recordId);\r\n    rec.provisioningStatus \u003d \u0027FAILED\u0027;\r\n    rec.provisioningError \u003d `Failed to create trigger for step ${nextStep}: ${e.message}`;\r\n    updateProvisionRecord_(recordId, rec);\r\n  }\r\n}\r\n\r\n/**\r\n * The main state machine engine. Called by a trigger.\r\n * It reads the current state from the provision record and executes the corresponding step.\r\n */\r\nfunction runProvisioningStateMachine() {\r\n  // Always cancel triggers first to prevent orphaned loops if something goes wrong.\r\n  _cancelProvisioningTriggers_();\r\n\r\n  const P \u003d PropertiesService.getScriptProperties();\r\n  const recordId \u003d P.getProperty(\u0027PROVISION_RECORD_ID\u0027);\r\n  const expectedStep \u003d P.getProperty(\u0027PROVISION_NEXT_STEP\u0027);\r\n\r\n  if (!recordId) {\r\n    Logger.log(\u0027State machine ran without a recordId in properties. Halting.\u0027);\r\n    return;\r\n  }\r\n\r\n  let rec;\r\n  try {\r\n    rec \u003d readProvisionRecord_(recordId);\r\n\r\n    // Check if the machine was triggered for a specific step and if it matches the record.\r\n    if (expectedStep \u0026\u0026 rec.provisioningStatus !\u003d\u003d expectedStep) {\r\n        Logger.log(`State machine halted. Trigger was for step \u0027${expectedStep}\u0027, but record status is \u0027${rec.provisioningStatus}\u0027. This may happen if a step was manually re-run.`);\r\n        return;\r\n    }\r\n\r\n    Logger.log(`Running step: ${rec.provisioningStatus}`);\r\n\r\n    // The main state dispatcher\r\n    switch (rec.provisioningStatus) {\r\n      case \u0027CREATE_SHEETS\u0027:   _step_createSheets(rec);   break;\r\n      case \u0027CREATE_BUCKET\u0027:   _step_createBucket(rec);   break;\r\n      case \u0027CREATE_SCRIPTS\u0027:  _step_createScripts(rec);  break;\r\n      case \u0027DEPLOY_HUB\u0027:      _step_deployHub(rec);      break;\r\n      case \u0027DEPLOY_PORTAL\u0027:   _step_deployPortal(rec);   break;\r\n      case \u0027DEPLOY_OUTBOUND\u0027: _step_deployOutbound(rec); break;\r\n      case \u0027DEPLOY_RESULTS\u0027:  _step_deployResults(rec);  break;\r\n      case \u0027FINALIZE_PROPS\u0027:  _step_finalizeProps(rec);  break;\r\n      case \u0027SCHEDULE_FINAL_JOB\u0027: _step_scheduleFinalJob(rec); break;\r\n      case \u0027COMPLETED\u0027:\r\n        Logger.log(`Provisioning for record ${recordId} is complete.`);\r\n        P.deleteProperty(\u0027PROVISION_RECORD_ID\u0027);\r\n        P.deleteProperty(\u0027PROVISION_NEXT_STEP\u0027);\r\n        break; // End of the line\r\n      default:\r\n        throw new Error(`Unknown provisioning status: \u0027${rec.provisioningStatus}\u0027.`);\r\n    }\r\n  } catch (e) {\r\n    Logger.log(`Error in state machine at step \u0027${rec ? rec.provisioningStatus : \u0027UNKNOWN\u0027}\u0027: ${e.message}\\n${e.stack}`);\r\n    if (rec) {\r\n      rec.provisioningStatus \u003d \u0027FAILED\u0027;\r\n      rec.provisioningError \u003d `Error during step \u0027${rec.provisioningStatus}\u0027: ${e.message}`;\r\n      updateProvisionRecord_(recordId, rec);\r\n    }\r\n  }\r\n}\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 1b) NEW: Sequential Step Implementations \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\n\r\nfunction _step_createSheets(rec) {\r\n  const F \u003d FACTORY_DEFAULTS();\r\n  const clientName \u003d rec.client.name;\r\n  const clientRoot \u003d DriveApp.getFolderById(rec.drive.clientFolderId);\r\n  const archiveFolder \u003d DriveApp.getFolderById(rec.drive.archiveFolderId);\r\n\r\n  // Sheets\r\n  const outboundCopy \u003d gdrive_copyFile_(F.TPL_OUTBOUND_SS_ID, `${clientName} - Outbound Console`, clientRoot.getId());\r\n  const OUTBOUND_SS_ID \u003d outboundCopy.id;\r\n  _ensureOutboundSkeleton_(OUTBOUND_SS_ID);\r\n  protectHeaders_(OUTBOUND_SS_ID, []);\r\n  protectCreditSheet_(OUTBOUND_SS_ID, []);\r\n\r\n  const resultsCopy \u003d gdrive_copyFile_(F.TPL_RESULTS_SS_ID, `${clientName} - Results`, clientRoot.getId());\r\n  const RESULTS_SS_ID \u003d resultsCopy.id;\r\n  _ensureResultsSkeleton_(RESULTS_SS_ID);\r\n  protectHeaders_(RESULTS_SS_ID, []);\r\n\r\n  const archiveFile \u003d SpreadsheetApp.create(`${clientName} - Archive`);\r\n  gdrive_moveFile_(archiveFile.getId(), archiveFolder.getId());\r\n  const ARCHIVE_ID \u003d archiveFile.getId();\r\n  _ensureArchiveSheet_(ARCHIVE_ID);\r\n  protectArchive_(ARCHIVE_ID, []);\r\n\r\n  // Update record\r\n  rec.sheets.outboundId \u003d OUTBOUND_SS_ID;\r\n  rec.sheets.resultsId \u003d RESULTS_SS_ID;\r\n  rec.sheets.archiveId \u003d ARCHIVE_ID;\r\n  rec.provisioningStatus \u003d \u0027CREATE_BUCKET\u0027;\r\n  updateProvisionRecord_(rec.recordFileId, rec);\r\n\r\n  // Schedule next step\r\n  _scheduleNextStep_(rec.recordFileId, \u0027CREATE_BUCKET\u0027);\r\n}\r\n\r\n\r\nfunction _step_createBucket(rec) {\r\n  const F \u003d FACTORY_DEFAULTS();\r\n  const slug \u003d rec.client.slug;\r\n  const opts \u003d rec._originalOpts;\r\n  let bucketWriters \u003d [].concat(opts.bucketWriters || []);\r\n  if (!bucketWriters.length) bucketWriters \u003d [DEFAULT_BUCKET_WRITER];\r\n\r\n  // Bucket\r\n  const bucketBase \u003d `${slug}-retell-calling-reference-data`;\r\n  const bucketName \u003d _createClientBucket_(F.GCP_PROJECT_ID, bucketBase, F.BUCKET_LOCATION);\r\n  if (bucketWriters.length) _ensureBucketIamWriters_(bucketName, bucketWriters);\r\n  const GCS_RESULTS_PATH \u003d \u0027raw_leads/inbound_webhook.csv\u0027;\r\n\r\n  // Write agent configuration JSON for Cloud Run services\r\n  try {\r\n    const agents \u003d Object.assign({1:\u0027\u0027,2:\u0027\u0027,3:\u0027\u0027,4:\u0027\u0027,5:\u0027\u0027,6:\u0027\u0027,7:\u0027\u0027,8:\u0027\u0027}, opts.agents || {});\r\n    const agentCfg \u003d { agents: {} };\r\n    Object.values(agents).forEach(id \u003d\u003e {\r\n      if (id) agentCfg.agents[id] \u003d {\r\n        bucket_name: bucketName,\r\n        csv_path: GCS_RESULTS_PATH,\r\n        use_firestore: false,\r\n        key_column: \u0027Phone\u0027,\r\n        handler: \u0027handlers.client_template\u0027, // MODIFIED: Point all new agents to the single generic handler\r\n      };\r\n    });\r\n    _writeJsonToBucket_(bucketName, \u0027agent_config.json\u0027, agentCfg);\r\n  } catch (e) { Logger.log(\u0027agent_config write failed: \u0027 + e); }\r\n\r\n  // Update record\r\n  rec.gcs.bucket \u003d bucketName;\r\n  rec.gcs.path \u003d GCS_RESULTS_PATH;\r\n  rec.gcs.region \u003d F.BUCKET_LOCATION;\r\n  rec.provisioningStatus \u003d \u0027CREATE_SCRIPTS\u0027;\r\n  updateProvisionRecord_(rec.recordFileId, rec);\r\n\r\n  // Schedule next step\r\n  _scheduleNextStep_(rec.recordFileId, \u0027CREATE_SCRIPTS\u0027);\r\n}\r\n\r\n\r\nfunction _step_createScripts(rec) {\r\n  const F \u003d FACTORY_DEFAULTS();\r\n  const clientName \u003d rec.client.name;\r\n  const clientRoot \u003d DriveApp.getFolderById(rec.drive.clientFolderId);\r\n  const adminClientRoot \u003d DriveApp.getFolderById(rec.drive.adminFolderId);\r\n\r\n  // Hub + Portal (standalone)\r\n  const portalCopy \u003d gdrive_copyFile_(F.TPL_PORTAL_SCRIPT_ID, `${clientName} - Client Portal`, clientRoot.getId());\r\n  const PORTAL_SCRIPT_ID \u003d portalCopy.id;\r\n  const hubCopy    \u003d gdrive_copyFile_(F.TPL_HUB_SCRIPT_ID, `${clientName} - Hub`, adminClientRoot.getId());\r\n  const HUB_SCRIPT_ID \u003d hubCopy.id;\r\n\r\n  // Inject the Config Loader into Standalone Scripts\r\n  injectConfigLoader_(HUB_SCRIPT_ID);\r\n  injectConfigLoader_(PORTAL_SCRIPT_ID);\r\n\r\n  // Inject the Webhook Polling logic into the Hub\r\n  injectWebhookPolling_(HUB_SCRIPT_ID);\r\n\r\n  _ensureWebAppManifest_(HUB_SCRIPT_ID, F.CT_TZ, \u0027ANYONE\u0027, \u0027USER_DEPLOYING\u0027);\r\n  _ensureBootstrapFile_(HUB_SCRIPT_ID);\r\n  _ensureWebAppManifest_(PORTAL_SCRIPT_ID, F.CT_TZ, \u0027ANYONE\u0027, \u0027USER_DEPLOYING\u0027);\r\n  _ensureBootstrapFile_(PORTAL_SCRIPT_ID);\r\n\r\n  // Update Record\r\n  rec.scripts.hubScriptId \u003d HUB_SCRIPT_ID;\r\n  rec.scripts.portalScriptId \u003d PORTAL_SCRIPT_ID;\r\n  rec.provisioningStatus \u003d \u0027DEPLOY_HUB\u0027;\r\n  updateProvisionRecord_(rec.recordFileId, rec);\r\n\r\n  // Schedule next step\r\n  _scheduleNextStep_(rec.recordFileId, \u0027DEPLOY_HUB\u0027);\r\n}\r\n\r\n\r\nfunction _step_deployHub(rec) {\r\n  const HUB_SCRIPT_ID \u003d rec.scripts.hubScriptId;\r\n  waitUntilProjectExists_(HUB_SCRIPT_ID, SCRIPT_VISIBILITY_TIMEOUT_MS);\r\n  Utilities.sleep(1500);\r\n\r\n  const hubDep     \u003d _deployProject_(HUB_SCRIPT_ID, \u0027v1 - initial\u0027);\r\n  const hubExec    \u003d (hubDep.entryPoints||[]).filter(e\u003d\u003ee.webApp).map(e\u003d\u003ee.webApp.url)[0] || \u0027\u0027;\r\n\r\n  // Update Record\r\n  rec.scripts.hubExecUrl \u003d hubExec;\r\n  rec.provisioningStatus \u003d \u0027DEPLOY_PORTAL\u0027;\r\n  updateProvisionRecord_(rec.recordFileId, rec);\r\n\r\n  // Schedule next step\r\n  _scheduleNextStep_(rec.recordFileId, \u0027DEPLOY_PORTAL\u0027);\r\n}\r\n\r\n\r\nfunction _step_deployPortal(rec) {\r\n  const PORTAL_SCRIPT_ID \u003d rec.scripts.portalScriptId;\r\n  waitUntilProjectExists_(PORTAL_SCRIPT_ID, SCRIPT_VISIBILITY_TIMEOUT_MS);\r\n  Utilities.sleep(1500);\r\n\r\n  const portalDep  \u003d _deployProject_(PORTAL_SCRIPT_ID, \u0027v1 - initial\u0027);\r\n  const portalExec \u003d (portalDep.entryPoints||[]).filter(e\u003d\u003ee.webApp).map(e\u003d\u003ee.webApp.url)[0] || \u0027\u0027;\r\n\r\n  // Update Record\r\n  rec.scripts.portalExecUrl \u003d portalExec;\r\n  rec.provisioningStatus \u003d \u0027DEPLOY_OUTBOUND\u0027;\r\n  updateProvisionRecord_(rec.recordFileId, rec);\r\n\r\n  // Schedule next step\r\n  _scheduleNextStep_(rec.recordFileId, \u0027DEPLOY_OUTBOUND\u0027);\r\n}\r\n\r\n\r\nfunction _step_deployOutbound(rec) {\r\n  const F \u003d FACTORY_DEFAULTS();\r\n  const clientName \u003d rec.client.name;\r\n  const OUTBOUND_SS_ID \u003d rec.sheets.outboundId;\r\n\r\n  // Find the script that was copied with the template, waiting up to 2 minutes for it to appear.\r\n  let script \u003d chooseBestBoundScript_(OUTBOUND_SS_ID);\r\n  if (!script) {\r\n      const until \u003d Date.now() + 120000;\r\n      while (!script \u0026\u0026 Date.now() \u003c until) {\r\n          Utilities.sleep(5000);\r\n          script \u003d chooseBestBoundScript_(OUTBOUND_SS_ID);\r\n      }\r\n  }\r\n\r\n  // If we found the copied script, deploy it. If not, create a new one.\r\n  const outboundBound \u003d ensureBoundScriptDeploy_(OUTBOUND_SS_ID, \u0027Outbound App – \u0027 + clientName, F.CT_TZ, {\r\n    allowCreateIfMissing: !script, // Only create if one wasn\u0027t found.\r\n    waitMs: 0 // We already handled the wait.\r\n  });\r\n\r\n  if (outboundBound.scriptId) {\r\n    injectConfigLoaderForBound_(outboundBound.scriptId, \u0027Outbound\u0027);\r\n  }\r\n\r\n  // Update Record\r\n  rec.scripts.outboundScriptId \u003d outboundBound.scriptId || null;\r\n  rec.scripts.outboundExecUrl \u003d outboundBound.execUrl || \u0027\u0027;\r\n  rec.scripts.outboundDevUrl \u003d outboundBound.devUrl || \u0027\u0027;\r\n  rec.provisioningStatus \u003d \u0027DEPLOY_RESULTS\u0027;\r\n  updateProvisionRecord_(rec.recordFileId, rec);\r\n\r\n  // Schedule next step\r\n  _scheduleNextStep_(rec.recordFileId, \u0027DEPLOY_RESULTS\u0027);\r\n}\r\n\r\n\r\nfunction _step_deployResults(rec) {\r\n  const F \u003d FACTORY_DEFAULTS();\r\n  const clientName \u003d rec.client.name;\r\n  const RESULTS_SS_ID \u003d rec.sheets.resultsId;\r\n\r\n  // Find the script that was copied with the template, waiting up to 2 minutes for it to appear.\r\n  let script \u003d chooseBestBoundScript_(RESULTS_SS_ID);\r\n  if (!script) {\r\n      const until \u003d Date.now() + 120000;\r\n      while (!script \u0026\u0026 Date.now() \u003c until) {\r\n          Utilities.sleep(5000);\r\n          script \u003d chooseBestBoundScript_(RESULTS_SS_ID);\r\n      }\r\n  }\r\n\r\n  // If we found the copied script, deploy it. If not, create a new one.\r\n  const resultsBound \u003d ensureBoundScriptDeploy_(RESULTS_SS_ID, \u0027Results App – \u0027 + clientName, F.CT_TZ, {\r\n    allowCreateIfMissing: !script, // Only create if one wasn\u0027t found.\r\n    waitMs: 0 // We already handled the wait.\r\n  });\r\n\r\n  if (resultsBound.scriptId) {\r\n    injectConfigLoaderForBound_(resultsBound.scriptId, \u0027Results\u0027);\r\n  }\r\n\r\n  // Update Record\r\n  rec.scripts.resultsScriptId \u003d resultsBound.scriptId || null;\r\n  rec.scripts.resultsExecUrl \u003d resultsBound.execUrl || \u0027\u0027;\r\n  rec.scripts.resultsDevUrl \u003d resultsBound.devUrl || \u0027\u0027;\r\n  rec.provisioningStatus \u003d \u0027FINALIZE_PROPS\u0027;\r\n  updateProvisionRecord_(rec.recordFileId, rec);\r\n\r\n  // Schedule next step\r\n  _scheduleNextStep_(rec.recordFileId, \u0027FINALIZE_PROPS\u0027);\r\n}\r\n\r\n\r\nfunction _step_finalizeProps(rec) {\r\n  const F \u003d FACTORY_DEFAULTS();\r\n  const opts \u003d rec._originalOpts;\r\n  const clientToken   \u003d String(opts.clientToken || (\u0027tok_\u0027+_rand_()));\r\n  const portalPass    \u003d String(opts.portalPassword || \u0027changeme\u0027);\r\n  const allowedEmails \u003d [].concat(opts.allowedEmails || []);\r\n  const agents \u003d Object.assign({1:\u0027\u0027,2:\u0027\u0027,3:\u0027\u0027,4:\u0027\u0027,5:\u0027\u0027,6:\u0027\u0027,7:\u0027\u0027,8:\u0027\u0027}, opts.agents || {});\r\n  const fromNums \u003d Object.assign({1:\u0027\u0027,2:\u0027\u0027,3:\u0027\u0027,4:\u0027\u0027,5:\u0027\u0027,6:\u0027\u0027,7:\u0027\u0027,8:\u0027\u0027}, opts.fromNumbers || {});\r\n  const retellKey     \u003d String(opts.retellApiKey || \u0027\u0027);\r\n  const retellUrlInfo \u003d canonicalRetellBatchUrl_(opts.retellApiUrl || FACTORY_DEFAULTS().RETELL_URL);\r\n  const retellApiUrl  \u003d retellUrlInfo.url;\r\n  const recall \u003d Object.assign({ noAnswer:5, answered:30 }, opts.recallDays || {});\r\n\r\n  if (retellUrlInfo.normalized) {\r\n    if (retellUrlInfo.reason \u003d\u003d\u003d \u0027missing\u0027) {\r\n      Logger.log(\u0027Provisioning: RETELL_URL missing or blank. Seeding canonical: \u0027 + retellApiUrl);\r\n    } else {\r\n      Logger.log(\u0027Provisioning: Normalized RETELL_URL to canonical endpoint: \u0027 + retellApiUrl + \u0027 (was \u0027 + (retellUrlInfo.previous || \u0027\u0027) + \u0027)\u0027);\r\n    }\r\n  }\r\n\r\n  if (rec._originalOpts) {\r\n    rec._originalOpts.retellApiUrl \u003d retellApiUrl;\r\n  }\r\n\r\n  // Seed Outbound:Credit defaults (best‑effort)\r\n  try {\r\n    const ssOut \u003d SpreadsheetApp.openById(rec.sheets.outboundId);\r\n    const shC \u003d ssOut.getSheetByName(\u0027Credit\u0027) || ssOut.insertSheet(\u0027Credit\u0027);\r\n    shC.getRange(\u0027I3\u0027).setValue(recall.noAnswer);\r\n    shC.getRange(\u0027I5\u0027).setValue(recall.answered);\r\n    if (!shC.getRange(\u0027B1\u0027).getValue()) shC.getRange(\u0027B1\u0027).setValue(0);\r\n  } catch (_) {}\r\n\r\n  // Props payloads\r\n  const adminToken \u003d \u0027adm_\u0027 + _rand_();\r\n  const hubProps \u003d {\r\n    FOLDER_ID:         rec.drive.archiveFolderId,\r\n    OUTBOUND_SS_ID:    rec.sheets.outboundId,\r\n    RESULTS_SS_ID:     rec.sheets.resultsId,\r\n    RETELL_API_KEY:    retellKey,\r\n    RETELL_URL:        retellApiUrl,\r\n    CLIENT_TOKEN:      clientToken,\r\n    GCS_BUCKET:        rec.gcs.bucket,\r\n    GCS_RESULTS_PATH:  rec.gcs.path,\r\n    DEFAULT_RUN_LIMIT: String(F.DEFAULT_RUN_LIMIT),\r\n    MAX_PER_RUN:       String(F.DEFAULT_RUN_LIMIT),\r\n    CT_TZ:             F.CT_TZ,\r\n    ADMIN_TOKEN:       adminToken,\r\n    PORTAL_PASSWORD:   portalPass,\r\n    ALLOWED_SHEET_ID:  rec.sheets.outboundId,\r\n    ALLOWED_EMAILS:    allowedEmails.join(\u0027,\u0027),\r\n    AGENT_RUN_1: agents[1]||\u0027\u0027, AGENT_RUN_2: agents[2]||\u0027\u0027, AGENT_RUN_3: agents[3]||\u0027\u0027, AGENT_RUN_4: agents[4]||\u0027\u0027,\r\n    AGENT_RUN_5: agents[5]||\u0027\u0027, AGENT_RUN_6: agents[6]||\u0027\u0027, AGENT_RUN_7: agents[7]||\u0027\u0027, AGENT_RUN_8: agents[8]||\u0027\u0027,\r\n    FROM_RUN_1: fromNums[1]||\u0027\u0027, FROM_RUN_2: fromNums[2]||\u0027\u0027, FROM_RUN_3: fromNums[3]||\u0027\u0027, FROM_RUN_4: fromNums[4]||\u0027\u0027,\r\n    FROM_RUN_5: fromNums[5]||\u0027\u0027, FROM_RUN_6: fromNums[6]||\u0027\u0027, FROM_RUN_7: fromNums[7]||\u0027\u0027, FROM_RUN_8: fromNums[8]||\u0027\u0027,\r\n    PROVISION_RECORD_ID: rec.recordFileId, RECORD_ID: rec.recordFileId\r\n  };\r\n  const portalProps \u003d {\r\n    HUB_URL:           rec.scripts.hubExecUrl,\r\n    CLIENT_TOKEN:      clientToken,\r\n    OUTBOUND_SS_ID:    rec.sheets.outboundId,\r\n    RESULTS_SS_ID:     rec.sheets.resultsId,\r\n    DEFAULT_RUN_LIMIT: String(F.DEFAULT_RUN_LIMIT),\r\n    PORTAL_PASSWORD:   portalPass,\r\n    CT_TZ:             F.CT_TZ,\r\n    PROVISION_RECORD_ID: rec.recordFileId, RECORD_ID: rec.recordFileId\r\n  };\r\n  const outboundProps \u003d {\r\n    RESULTS_SS_ID: rec.sheets.resultsId,\r\n    OUTBOUND_SS_ID: rec.sheets.outboundId,\r\n    HUB_URL: rec.scripts.hubExecUrl,\r\n    CLIENT_TOKEN: clientToken,\r\n    RETELL_URL: retellApiUrl,\r\n    DEFAULT_RUN_LIMIT: String(F.DEFAULT_RUN_LIMIT),\r\n    MAX_PER_RUN:       String(F.DEFAULT_RUN_LIMIT),\r\n    PROVISION_RECORD_ID: rec.recordFileId, RECORD_ID: rec.recordFileId\r\n  };\r\n  const resultsProps \u003d {\r\n    HUB_URL: rec.scripts.hubExecUrl,\r\n    CLIENT_TOKEN: clientToken,\r\n    PROVISION_RECORD_ID: rec.recordFileId, RECORD_ID: rec.recordFileId\r\n  };\r\n\r\n  // Update Credit Ledger\r\n  try {\r\n    appendCreditLedgerRow_(CREDIT_LEDGER_SS_ID, {\r\n      client:        rec.client.name,\r\n      amountPaid:    0,\r\n      creditsGiven:  0,\r\n      outboundId:    rec.sheets.outboundId,\r\n      clientToken:   clientToken,\r\n      adminToken:    adminToken,\r\n      hubUrl:        rec.scripts.hubExecUrl,\r\n    });\r\n  } catch (e) { console.warn(\u0027Credit Ledger append failed: \u0027 + e); }\r\n\r\n  // Update Record\r\n  rec.props.hubProps \u003d hubProps;\r\n  rec.props.portalProps \u003d portalProps;\r\n  rec.props.outboundProps \u003d outboundProps;\r\n  rec.props.resultsProps \u003d resultsProps;\r\n  rec.provisioningStatus \u003d \u0027SCHEDULE_FINAL_JOB\u0027;\r\n  updateProvisionRecord_(rec.recordFileId, rec);\r\n\r\n  // Schedule next step\r\n  _scheduleNextStep_(rec.recordFileId, \u0027SCHEDULE_FINAL_JOB\u0027);\r\n}\r\n\r\n\r\nfunction _step_scheduleFinalJob(rec) {\r\n  const opts \u003d rec._originalOpts;\r\n  const autoFinalize \u003d (typeof opts.autoFinalize \u003d\u003d\u003d \u0027boolean\u0027) ? !!opts.autoFinalize : true;\r\n  const finalizeDelayMin \u003d Number(opts.finalizeDelayMin || DEFAULT_FINALIZE_DELAY_MIN);\r\n\r\n  const scheduled \u003d autoFinalize ? scheduleFinalize_(rec.recordFileId, finalizeDelayMin) :\r\n    { minutesFromNow: 0, runAtIso: \u0027\u0027, triggerId: \u0027\u0027 };\r\n\r\n  // Final update to the record\r\n  rec.scheduled \u003d scheduled;\r\n  rec.timestamps.completed \u003d new Date().toISOString();\r\n  rec.provisioningStatus \u003d \u0027COMPLETED\u0027;\r\n  delete rec._originalOpts; // Clean up the temporary options storage\r\n  updateProvisionRecord_(rec.recordFileId, rec);\r\n\r\n  // This is the last step, so we do not schedule another one.\r\n  Logger.log(`Provisioning chain completed for record ${rec.recordFileId}. Finalize job scheduled.`);\r\n}\r\n\r\n\r\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d 18) NEW: UI Helpers \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d **/\r\nfunction getProvisioningStatus(recordId) {\r\n  if (!recordId) {\r\n    return { ok: false, error: \u0027Record ID is required.\u0027 };\r\n  }\r\n  try {\r\n    const rec \u003d readProvisionRecord_(recordId);\r\n    // When completed, we also want to send the URLs back like the original function did.\r\n    // This avoids having to call another function.\r\n    let finalUrls \u003d null;\r\n    if (rec.provisioningStatus \u003d\u003d\u003d \u0027COMPLETED\u0027) {\r\n        const hubDev    \u003d (rec.scripts.hubExecUrl||\u0027\u0027).replace(/\\/exec(\\?.*)?$/,\u0027/dev\u0027);\r\n        const portalDev \u003d (rec.scripts.portalExecUrl||\u0027\u0027).replace(/\\/exec(\\?.*)?$/,\u0027/dev\u0027);\r\n        finalUrls \u003d {\r\n            hubAuthUrl: editorUrl_(rec.scripts.hubScriptId),\r\n            portalAuthUrl: editorUrl_(rec.scripts.portalScriptId),\r\n            outboundAuthUrl: sheetUrl_(rec.sheets.outboundId),\r\n            resultsAuthUrl: sheetUrl_(rec.sheets.resultsId),\r\n            hubExecUrl: rec.scripts.hubExecUrl,\r\n            portalExecUrl: rec.scripts.portalExecUrl,\r\n            // also include the record for full details\r\n            record: rec\r\n        };\r\n    }\r\n\r\n    return {\r\n      ok: true,\r\n      status: rec.provisioningStatus || \u0027UNKNOWN\u0027,\r\n      error: rec.provisioningError || null,\r\n      finalUrls: finalUrls\r\n    };\r\n  } catch (e) {\r\n    return { ok: false, status: \u0027UNKNOWN\u0027, error: `Failed to read record: ${e.message}` };\r\n  }\r\n}"}]}